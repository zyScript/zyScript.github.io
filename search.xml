<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android okHttp结合后端保存数据库数据</title>
      <link href="/2023/09/04/android-okhttp-jie-he-hou-duan-bao-cun-shu-ju-ku-shu-ju/"/>
      <url>/2023/09/04/android-okhttp-jie-he-hou-duan-bao-cun-shu-ju-ku-shu-ju/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h5><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE `user_operate_his` (  `id` varchar(20) NOT NULL COMMENT '操作ID',  `user_id` varchar(20) NOT NULL COMMENT '用户ID',  `operate_type` varchar(10) NOT NULL COMMENT '用户操作种类',  `operate` varchar(10) NOT NULL COMMENT '用户具体操作',  `time` datetime NOT NULL COMMENT '用户操作时间',  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、新建springboot项目"><a href="#2、新建springboot项目" class="headerlink" title="2、新建springboot项目"></a>2、新建springboot项目</h5><p>①实体类</p><pre class="line-numbers language-none"><code class="language-none">public class User {    private String id;    private String userId;    private String operateType;    private String operate;    private Date time;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②DAO层</p><pre class="line-numbers language-none"><code class="language-none">@Mapperpublic interface UserMapper {    /**     * 查询全部     * @return     */    @Select("select * from user_operate_his ")    List&lt;User&gt; selectAll();    @Insert("INSERT INTO user_operate_his (id, user_id, operate_type, operate, time) " +            "VALUES (#{id}, #{userId}, #{operateType}, #{operate}, #{time})")    int insert(User user);    @Update("UPDATE user_operate_his " +            "SET user_id = #{userId}, operate_type = #{operateType}, operate = #{operate}, time = #{time} " +            "WHERE id = #{id}")    int update(User user);    @Delete("delete from user_operate_his where id = #{id}")    int delete(String id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③服务层以及实现层</p><pre class="line-numbers language-none"><code class="language-none">/** * @author zy */public interface UserService {    /**     * 查询所有     * @return     */    List&lt;User&gt; selectAll();    /**     * 插入数据     * @return     */    int insert(User user);    int update(User user);    int delete(String id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/** * @author zy */@Servicepublic class UserServiceImpl implements UserService {   @Resource    UserMapper userMapper;    @Override    public List&lt;User&gt; selectAll() {        return userMapper.selectAll();    }    @Override    public int insert(User user) {        return userMapper.insert(user);    }    @Override    public int update(User user) {        return userMapper.update(user);    }    @Override    public int delete(String id) {        return userMapper.delete(id);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>④控制器层</p><pre class="line-numbers language-none"><code class="language-none">/** * @author zy */@RestControllerpublic class UserController {    @Resource    UserService userService;    @GetMapping("/select")    public List&lt;User&gt; selectAll() {        return userService.selectAll();    }    @PostMapping("/insert")    public int insert(@RequestBody User user){        System.out.println(user);        return userService.insert(user);    }    @PostMapping("/update/{id}")    public int update(@RequestBody User user, @PathVariable String id){        return userService.update(user);    }    @DeleteMapping("/delete/{id}")    public int delete(@PathVariable String id){        return userService.delete(id);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3、创建Android项目"><a href="#3、创建Android项目" class="headerlink" title="3、创建Android项目"></a>3、创建Android项目</h5><p>①在build.gradle中添加okhttp依赖</p><pre class="line-numbers language-none"><code class="language-none">implementation 'com.squareup.okhttp3:okhttp:4.9.1'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>②新建Activity  加入如下代码</p><pre class="line-numbers language-none"><code class="language-none">package com.example.mysql;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import org.json.JSONException;import org.json.JSONObject;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;public class InsertDataActivity extends AppCompatActivity {    private EditText idEditText;    private EditText operateEditText;    private EditText operateTypeEditText;    private EditText timeEditText;    private EditText userIdEditText;    private Button saveButton;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_insert_data);        idEditText = findViewById(R.id.idEditText);        operateEditText = findViewById(R.id.operateEditText);        operateTypeEditText = findViewById(R.id.operateTypeEditText);        timeEditText = findViewById(R.id.timeEditText);        userIdEditText = findViewById(R.id.userIdEditText);        saveButton = findViewById(R.id.saveButton);        saveButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                // 获取用户输入的数据                String id = idEditText.getText().toString();                String operate = operateEditText.getText().toString();                String operateType = operateTypeEditText.getText().toString();                String time = timeEditText.getText().toString();                String userId = userIdEditText.getText().toString();                // 构建 JSON 数据                JSONObject jsonObject = new JSONObject();                try {                    jsonObject.put("id", id);                    jsonObject.put("operate", operate);                    jsonObject.put("operateType", operateType);                    jsonObject.put("time", time);                    jsonObject.put("userId", userId);                } catch (JSONException e) {                    e.printStackTrace();                }                String jsonData = jsonObject.toString();                // 执行网络请求                sendDataToServer(jsonData);            }        });    }    private void sendDataToServer(final String data) {        new Thread(new Runnable() {            @Override            public void run() {                try {                    // 构建 JSON 数据                    String json = data;                    Log.e("Tag",json);                    // 创建 OkHttp 客户端实例                    OkHttpClient client = new OkHttpClient();                    // 创建 POST 请求对象                    Request request = new Request.Builder()                            .url("http://192.168.1.107:8080/insert")                            .post(RequestBody.create(MediaType.parse("application/json"), json))                            .build();                    // 发送 POST 请求                    Response response = client.newCall(request).execute();                    // 处理响应                    if (response.isSuccessful()) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Toast.makeText(InsertDataActivity.this, "保存成功", Toast.LENGTH_SHORT).show();                            }                        });                    } else {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Toast.makeText(InsertDataActivity.this, "保存失败", Toast.LENGTH_SHORT).show();                            }                        });                    }                } catch (Exception e) {                    e.printStackTrace();                    runOnUiThread(new Runnable() {                        @Override                        public void run() {                            Toast.makeText(InsertDataActivity.this, "网络连接失败", Toast.LENGTH_SHORT).show();                        }                    });                }            }        }).start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③修改布局文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout    xmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="match_parent"    android:layout_height="match_parent"    android:orientation="vertical"    android:padding="16dp"&gt;    &lt;EditText        android:id="@+id/idEditText"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:hint="ID" /&gt;    &lt;EditText        android:id="@+id/operateEditText"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:hint="Operate" /&gt;    &lt;EditText        android:id="@+id/operateTypeEditText"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:hint="Operate Type" /&gt;    &lt;EditText        android:id="@+id/timeEditText"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:hint="Time" /&gt;    &lt;EditText        android:id="@+id/userIdEditText"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:hint="User ID" /&gt;    &lt;Button        android:id="@+id/saveButton"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:text="保存" /&gt;&lt;/LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>④Androidmainfest文件中添加网络请求权限</p><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>⑤运行模拟器测试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android开发问题集合</title>
      <link href="/2023/09/04/android-kai-fa-wen-ti-ji-he/"/>
      <url>/2023/09/04/android-kai-fa-wen-ti-ji-he/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1、关于ui线程问题"><a href="#1、关于ui线程问题" class="headerlink" title="1、关于ui线程问题"></a>1、关于ui线程问题</h5><p><code>runOnUiThread</code> 是 Android 开发中的一个方法，它允许您在主线程（UI 线程）上执行代码块。在 Android 应用中，UI 操作必须在主线程上执行，以确保界面的响应性和稳定性，因此当您在后台线程（例如 OkHttp 的回调中）需要更新用户界面时，通常会使用 <code>runOnUiThread</code> 来在主线程上执行 UI 更新操作。</p><p>这是一个 <code>runOnUiThread</code> 的基本用法示例：</p><pre class="line-numbers language-none"><code class="language-none">runOnUiThread(new Runnable() {    @Override    public void run() {        // 在这里执行需要在主线程上执行的 UI 操作        resultTextView.setText("请求成功");    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述示例中，我们创建了一个匿名内部类 <code>Runnable</code>，并实现了 <code>run</code> 方法，该方法包含了在主线程上执行的 UI 操作，例如更新 <code>resultTextView</code> 的文本。然后，我们将这个 <code>Runnable</code> 对象传递给 <code>runOnUiThread</code> 方法，它将确保这段代码在主线程上运行。</p><p>这样做是为了避免在非主线程上直接更新 UI，因为这样做可能导致应用程序崩溃或出现不稳定的行为。所以，当您需要在后台线程中执行网络请求等操作并更新 UI 时，应该使用 <code>runOnUiThread</code> 或其他方式确保 UI 操作在主线程上执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqlLite操作</title>
      <link href="/2023/08/29/sqllite-cao-zuo/"/>
      <url>/2023/08/29/sqllite-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1、创建安卓项目，如图所示"><a href="#1、创建安卓项目，如图所示" class="headerlink" title="1、创建安卓项目，如图所示"></a>1、创建安卓项目，如图所示</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829213017412.png" alt="image-20230829213017412"></p><h5 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829213452541.png" alt="image-20230829213452541"></p><p>这两个依赖项的作用是将Room数据库库集成到你的Android应用程序中。Room提供了一种更高级的方式来管理应用程序中的数据库，通过简化SQLite的使用，并提供方便的注解来定义实体、查询和数据库操作。使用这些依赖项，你可以在应用程序中使用Room的功能，以更有效地处理数据库操作。（可以当做是Android下的mybatis）</p><h5 id="3、项目的目录结构如下"><a href="#3、项目的目录结构如下" class="headerlink" title="3、项目的目录结构如下"></a>3、项目的目录结构如下</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829213939188.png" alt="image-20230829213939188"></p><h5 id="4、创建用户实体类"><a href="#4、创建用户实体类" class="headerlink" title="4、创建用户实体类"></a>4、创建用户实体类</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829214335244.png" alt="image-20230829214335244"></p><h5 id="5、建立数据持久层，这里暂不写方法"><a href="#5、建立数据持久层，这里暂不写方法" class="headerlink" title="5、建立数据持久层，这里暂不写方法"></a>5、建立数据持久层，这里暂不写方法</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829215449284.png" alt="image-20230829215449284"></p><h5 id="6、定义一个数据库类-用于分离数据库结构和代码"><a href="#6、定义一个数据库类-用于分离数据库结构和代码" class="headerlink" title="6、定义一个数据库类  用于分离数据库结构和代码"></a>6、定义一个数据库类  用于分离数据库结构和代码</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829220015068.png" alt="image-20230829220015068"></p><h5 id="7、创建UserInfoActivity并修改页面布局"><a href="#7、创建UserInfoActivity并修改页面布局" class="headerlink" title="7、创建UserInfoActivity并修改页面布局"></a>7、创建UserInfoActivity并修改页面布局</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230829221009018.png" alt="image-20230829221009018"></p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- TableLayout是一个容器，用于以行和列的形式排列子视图。 --&gt;&lt;!-- android:stretchColumns="*"指定列应均匀拉伸以填充可用宽度。 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="8、新增模态框Activity以及页面布局"><a href="#8、新增模态框Activity以及页面布局" class="headerlink" title="8、新增模态框Activity以及页面布局"></a>8、新增模态框Activity以及页面布局</h5><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230830094647188.png" alt="image-20230830094647188"></p><h5 id="9、在Util包下增加提示工具类"><a href="#9、在Util包下增加提示工具类" class="headerlink" title="9、在Util包下增加提示工具类"></a>9、在Util包下增加提示工具类</h5><pre class="line-numbers language-none"><code class="language-none">public class ToastUtil {    public static void show(Context ctx, String desc) {        Toast.makeText(ctx, desc, Toast.LENGTH_SHORT).show();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="10、编写增添模态框代码"><a href="#10、编写增添模态框代码" class="headerlink" title="10、编写增添模态框代码"></a>10、编写增添模态框代码</h5><pre class="line-numbers language-none"><code class="language-none">public class AddModalActivity extends AppCompatActivity implements View.OnClickListener {    private EditText et_userName;    private EditText et_sex;    private UserDatabase userDatabase;    private Button btnSave;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_add_modal);        et_userName = findViewById(R.id.user_name);        et_sex = findViewById(R.id.user_sex);        btnSave = findViewById(R.id.btn_save);        btnSave.setOnClickListener(this);   //设置按钮监听时间    }    @Override    public void onClick(View view) {        if (view.getId() == R.id.btn_save){            //执行保存用户方法            saveUserInfo();        }    }    private void saveUserInfo() {        String userName = et_userName.getText().toString();        String sex = et_sex.getText().toString();        UserInfo userInfo = new UserInfo();        userInfo.setUsername(userName);        userInfo.setSex(sex);        //执行插入语句        userDatabase.userDao().insert(userInfo);        //清空输入框        et_userName.setText("");        et_sex.setText("");        //给出提示信息        ToastUtil.show(this,"保存成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>11、UserInfoActivity中增加打开模态框的代码</p><pre class="line-numbers language-none"><code class="language-none">package com.example.sqlite_crud;import androidx.appcompat.app.AppCompatActivity;import androidx.room.Room;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TableLayout;import com.example.sqlite_crud.R;import com.example.sqlite_crud.database.UserDatabase;public class UserInfoActivity extends AppCompatActivity implements View.OnClickListener {    private TableLayout tableLayout;   //用于表示表格数据的布局    private UserDatabase userDatabase;   //数据库实例    private Button btn_add;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_user_info);        //获取 TableLayout控件        tableLayout = findViewById(R.id.table_layout);        btn_add = findViewById(R.id.btn_add);        btn_add.setOnClickListener(this);    }    //打开模态框    @Override    public void onClick(View view) {        //打开新增模态框        if (view.getId() == R.id.btn_add){            Intent intent = new Intent(this,AddModalActivity.class);            startActivity(intent);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>11、</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mqtt协议</title>
      <link href="/2023/08/28/mqtt-xie-yi/"/>
      <url>/2023/08/28/mqtt-xie-yi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p><p><img src="https://static.runoob.com/images/mix/mqtt-fidge-2.svg" alt="img"></p><hr><h2 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h2><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p><ul><li>（1）精简，不添加可有可无的功能；</li><li>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</li><li>（3）允许用户动态创建主题，零运维成本；</li><li>（4）把传输量降到最低以提高传输效率；</li><li>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</li><li>（6）支持连续的会话控制；</li><li>（7）理解客户端计算能力可能很低；</li><li>（8）提供服务质量管理；</li><li>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li></ul><hr><h2 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h2><p>MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p><ul><li><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p><p>这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p></li><li><p>（2）对负载内容屏蔽的消息传输。</p></li><li><p>（3）使用TCP/IP提供网络连接。</p><p>主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p></li><li><p>（4）有三种消息发布服务质量：</p><p>“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p><p>“至少一次”，确保消息到达，但消息重复可能会发生。</p><p>“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p></li><li><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p><p>这就是为什么在介绍里说它非常适合”在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p></li><li><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p><p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p><p>Testament：遗嘱机制，功能类似于Last Will。</p></li></ul><hr><h2 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h2><h3 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h3><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><ul><li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li><li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li></ul><h3 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h3><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p><p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p><h3 id="4-3-MQTT客户端"><a href="#4-3-MQTT客户端" class="headerlink" title="4.3 MQTT客户端"></a>4.3 MQTT客户端</h3><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><ul><li>（1）发布其他客户端可能会订阅的信息；</li><li>（2）订阅其它客户端发布的消息；</li><li>（3）退订或删除应用程序的消息；</li><li>（4）断开与服务器连接。</li></ul><h3 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h3><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p><ul><li>（1）接受来自客户的网络连接；</li><li>（2）接受客户发布的应用信息；</li><li>（3）处理来自客户端的订阅和退订请求；</li><li>（4）向订阅的客户转发应用程序消息。</li></ul><h3 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h3><p><strong>一、订阅（Subscription）</strong></p><p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p><p><strong>二、会话（Session）</strong></p><p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p><p><strong>三、主题名（Topic Name）</strong></p><p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p><p><strong>四、主题筛选器（Topic Filter）</strong></p><p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p><p><strong>五、负载（Payload）</strong></p><p>消息订阅者所具体接收的内容。</p><h3 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p><ul><li>（1）Connect。等待与服务器建立连接。</li><li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li><li>（3）Subscribe。等待完成订阅。</li><li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li><li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li></ul><hr><h2 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p><ul><li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li><li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li><li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li></ul><h3 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h3><p>固定头存在于所有MQTT数据包中，其结构如下：</p><p><strong>5.1.1 MQTT数据包类型</strong></p><p>位置：Byte 1中bits 7-4。</p><p>相于一个4位的无符号值，类型、取值及描述如下：</p><p><strong>5.1.2 标识位</strong></p><p>位置：Byte 1中bits 3-0。</p><p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p><p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p><p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p><pre class="line-numbers language-none"><code class="language-none">Ø00：最多一次，即：&lt;=1Ø01：至少一次，即：&gt;=1Ø10：一次，即：=1Ø11：预留<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。</p><h3 id="5-1-3-剩余长度（Remaining-Length）"><a href="#5-1-3-剩余长度（Remaining-Length）" class="headerlink" title="5.1.3 剩余长度（Remaining Length）"></a>5.1.3 剩余长度（Remaining Length）</h3><p>地址：Byte 2。</p><p>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p><h3 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h3><p>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p><p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p><h3 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h3><p>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p><ul><li>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</li><li>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li><li>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li><li>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot集成jjwt</title>
      <link href="/2023/08/18/springboot-ji-cheng-jjwt/"/>
      <url>/2023/08/18/springboot-ji-cheng-jjwt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java Web Token 概念</p><p>JSON Web Token (JWT) 是一个开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于将信息作为 JSON 对象安全地在各方之间传输信息。此信息可以验证和信任，因为它是数字签名。JWT 可以使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 进行公钥/私钥对进行签名。</p><h4 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h4><p>JSON Web 令牌以紧凑的形式由三个部分组成，由点（.）分隔，它们包括：</p><ul><li>Header</li><li>Payload</li><li>Signature</li></ul><p>将上面三部分用（.）拼接起来就形成了 JWT，因此，JWT 的格式通常如下所示。</p><pre class="line-numbers language-none"><code class="language-none">xxxxx.yyyyy.zzzzz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>标头通常由两部分组成：token 的类型（typ）和正在使用的签名算法（alg），如 HMAC SHA256 或 RSA。</p><p>例如：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>  <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，此 JSON 编码为 Base64Url，以形成 JWT 的第一部分。</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>token 的第二部分是有效负载，其中包含 claims。claims 是关于实体（通常为用户）和其他数据的语句。</p><p>示例有效负载可能是：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>  <span class="token property">"admin"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后对有效负载进行 Base64Url 编码，以形成 JSON Web 令牌的第二部分。</p><p>请注意，对于已签名的 token，此信息虽然可防止篡改，但任何人都可以阅读。除非对 JWT 进行加密，否则不要将机密信息放在 JWT 的有效负载或标头元素中。</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>要创建签名部分，您必须使用编码标头、编码有效负载、机密、标头中指定的算法，并签名。</p><p>例如，如果要使用 HMAC SHA256 算法，将采用以下方式创建签名：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">HMACSHA256</span><span class="token punctuation">(</span>  <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span>  <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>  secret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>签名用于验证信息在传输过程中不被篡改，对于使用私钥签名的 token，它还可以验证 JWT 的发件人是否为它所说的发件人。</p><p>1、先引入依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;    &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、定义配置文件</p><p>在使用JWT时，以下几个配置是必要的：</p><ol><li><strong>密钥（Secret Key）：</strong> 密钥用于生成和验证JWT的签名，确保它的机密性。这是生成和验证JWT所必需的关键要素之一。</li><li><strong>签名算法（Algorithm）：</strong> 指定用于签名JWT的算法。常见的算法包括 HS256、RS256 等。您需要确保使用安全且合适的签名算法。</li><li><strong>签发者（Issuer）：</strong> JWT的签发者标识谁生成了JWT。通常是一个字符串标识符，用于标识生成JWT的应用程序或服务。</li><li><strong>过期时间（Expiration Time）：</strong> JWT包含一个过期时间，一旦过期，JWT将不再被接受。这是为了限制JWT的生命周期，提高安全性。</li><li><strong>接收者（Audience）：</strong> JWT的接收者表示谁预期接收并使用JWT。它通常是应用程序或服务的标识符。</li></ol><pre class="line-numbers language-none"><code class="language-none"># 密钥jwt.secret = 你的秘钥# 签名算法：HS256,HS384,HS512,RS256,RS384,RS512,ES256,ES384,ES512,PS256,PS384,PS512jwt.header.alg = HS256（这里选择HS256）#jwt签发者jwt.payload.registerd-claims.iss = （签发者名称）#jwt过期时间（单位：毫秒）jwt.payload.registerd-claims.exp = （过期时间）#jwt接收者jwt.payload.registerd-claims.aud = （签收者）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>除了秘钥和过期时间外  其它都是可选的</strong></p><p>定义JWT的请求头</p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class JwtHeader {    private String alg;    private String typ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有效负载</p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class JwtClaims {    private String iss;   //签发者    private String exp;  //过期时间    private String sub;  //类型    private String aud;  //签收者<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义JWT请求体</p><pre class="line-numbers language-none"><code class="language-none">@Datapublic class JwtPayload {    private JwtClaims JwtClaims;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>封装完整JWT</p><pre class="line-numbers language-none"><code class="language-none">@Component@ConfigurationProperties(prefix = "jwt")   //批量绑定配置文件中的属性public class JwtProperties {    private String secret;    private JwtHeader header;    private JwtPayload payload;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@Conponent注解将其注册为bean</p><p>@@ConfigurationProperties批量绑定配置文件中信息</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>向 <code>JWTUtil.java</code> 文件中添加如下代码进行初始化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JwtUtil</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token class-name">JwtProperties</span> jwtProperties<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加生成密钥方法</p><p>在 <code>JWTUtil.java</code> 中创建 generalSecretKey 方法来生成密钥，生成的过程需要使用 JWT 的方法 SecretKeySpec 来生成密钥，该密钥在创建 JWT 和验证 JWT 的时候都会用到且相同，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">/**    * 由字符串生成加密key    * @return    */   private SecretKey generalKey() {       // 本地的密码解码       byte[] encodedKey = Base64.decodeBase64(jwtProperties.getSecret());       // 根据给定的字节数组使用AES加密算法构造一个密钥       SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES");       return key;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="创建jwt实体"><a href="#创建jwt实体" class="headerlink" title="创建jwt实体"></a>创建jwt实体</h5><pre class="line-numbers language-none"><code class="language-none">/**   * 创建jwt   * @param subject   * @return   * @throws Exception   */  public String createJWT(String subject) throws Exception {      // 生成JWT的时间      long nowTime = System.currentTimeMillis();      Date nowDate = new Date(nowTime);      // 生成签名的时候使用的秘钥secret，切记这个秘钥不能外露，是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt的      SecretKey key = generalKey();      ScriptEngineManager manager = new ScriptEngineManager();      ScriptEngine se = manager.getEngineByName("js");      int expireTime = 0;      try {          expireTime =(int) se.eval(jwtProperties.getPayload().getRegisterdClaims().getExp());      } catch (ScriptException e) {          e.printStackTrace();      }      // 为payload添加各种标准声明和私有声明      DefaultClaims defaultClaims = new DefaultClaims();      defaultClaims.setIssuer(jwtProperties.getPayload().getRegisterdClaims().getIss());      defaultClaims.setExpiration(new Date(System.currentTimeMillis() + expireTime));      defaultClaims.setSubject(subject);      defaultClaims.setAudience(jwtProperties.getPayload().getRegisterdClaims().getAud());      JwtBuilder builder = Jwts.builder() // 表示new一个JwtBuilder，设置jwt的body              .setClaims(defaultClaims)              .setIssuedAt(nowDate) // iat(issuedAt)：jwt的签发时间              .signWith(SignatureAlgorithm.forName(jwtProperties.getHeader().getAlg()), key); // 设置签名，使用的是签名算法和签名使用的秘钥      return builder.compact();  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="解析jwt"><a href="#解析jwt" class="headerlink" title="解析jwt"></a>解析jwt</h5><pre class="line-numbers language-none"><code class="language-none">/** * 解密jwt * * @param jwt * @return * @throws Exception */public Claims parseJWT(String jwt) throws Exception {    SecretKey key = generateKeyFromSecret(); // 签名秘钥，和生成的签名的秘钥一模一样    Claims claims = Jwts.parser() // 得到DefaultJwtParser            .setSigningKey(key) // 设置签名的秘钥            .parseClaimsJws(jwt).getBody(); // 设置需要解析的jwt    return claims;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法或可重构成</p><pre class="line-numbers language-none"><code class="language-none">@Componentpublic class JwtUtil {    @Autowired    private JwtProperties jwtProperties;    // 从配置文件获取发行者和受众    private final String ISSUER = jwtProperties.getPayload().getClaims().getIss();   //签发人    private final String AUDIENCE = jwtProperties.getPayload().getClaims().getAud();   //受众    private final String ALG = jwtProperties.getHeader().getAlg();  //算法    /**     * 从密钥字符串生成加密密钥     *     * @return 生成的密钥     */    private SecretKey generateKeyFromSecret() {        byte[] encodedKey = Base64.decodeBase64(jwtProperties.getSecret());        return new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES");    }    /**     * 创建 JWT     *     * @param subject JWT 的主题（通常是用户标识）     * @return 生成的 JWT 字符串     */    public String createJWT(String subject) {        SecretKey key = generateKeyFromSecret();        long nowTime = System.currentTimeMillis();        Date nowDate = new Date(nowTime);        // 从脚本中获取过期时间        int expireTime = getExpirationFromScript();        // 构建 JWT 的声明部分        Claims claims = Jwts.claims()                .setIssuer(ISSUER)                .setExpiration(new Date(nowTime + expireTime))                .setSubject(subject)                .setAudience(AUDIENCE);        // 使用声明、签发时间、签名算法和密钥构建 JWT        return Jwts.builder()                .setClaims(claims)   //声明                .setIssuedAt(nowDate)  //签发时间                .signWith(SignatureAlgorithm.forName(ALG), key)  //签名算法                .compact();    }    /**     * 解析 JWT 并返回声明     *     * @param jwt 要解析的 JWT 字符串     * @return 解析后的声明     */    public Claims parseJWT(String jwt) {        SecretKey key = generateKeyFromSecret();        return Jwts.parser()                .setSigningKey(key)                .parseClaimsJws(jwt)                .getBody();    }    /**     * 从脚本中获取过期时间     *     * @return 过期时间（秒）     */    private int getExpirationFromScript() {        ScriptEngineManager manager = new ScriptEngineManager();        ScriptEngine se = manager.getEngineByName("js");        int expireTime = 0;        try {            expireTime = (int) se.eval(jwtProperties.getPayload().getClaims().getExp());        } catch (ScriptException e) {            e.printStackTrace();        }        return expireTime;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此   JWT的创建和解析已经完成</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/17/mysql/"/>
      <url>/2023/08/17/mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="title-mysqldate-2023-08-17-08-27-13tags"><a href="#title-mysqldate-2023-08-17-08-27-13tags" class="headerlink" title="title: mysqldate: 2023-08-17 08:27:13tags:"></a>title: mysql<br>date: 2023-08-17 08:27:13<br>tags:</h2><h4 id="1、mysql的模式匹配"><a href="#1、mysql的模式匹配" class="headerlink" title="1、mysql的模式匹配"></a>1、mysql的模式匹配</h4><p>mysql的模式匹配有两种</p><ul><li>使用 <code>LIKE</code> 和 <code>NOT LIKE</code> 比较操作符。</li><li>使用 <code>REGEXP</code> 和 <code>NOT REGEXP</code> 操作符。</li></ul><p>如新建一张表</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE pet(    id int(10),    name char(20),    species char(10),    sex char(10),    age int(5));INSERT INTO pet VALUES(01,'Fluffy','dog','female',2);INSERT INTO pet VALUES(02,'Cici','cat','female',1);INSERT INTO pet VALUES(03,'BUffy','cat','male',3);INSERT INTO pet VALUES(04,'Lili','dog','female',1);INSERT INTO pet VALUES(05,'Claws','dog','male',2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="使用LIKE-和-NOT-LIKE比较操作符："><a href="#使用LIKE-和-NOT-LIKE比较操作符：" class="headerlink" title="使用LIKE 和 NOT LIKE比较操作符："></a>使用<code>LIKE</code> 和 <code>NOT LIKE</code>比较操作符：</h5><p>查询所有以L开头的所有名字</p><pre class="line-numbers language-none"><code class="language-none">select * from pet where name like 'L%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817083636748.png" alt="image-20230817083636748"></p><p>查询所有以i结尾的名字</p><pre class="line-numbers language-none"><code class="language-none">select * from pet where name like '%i';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817083648219.png" alt="image-20230817083648219"></p><p>查询长度为4个字符的名字</p><pre class="line-numbers language-none"><code class="language-none">select * from pet where name like '____';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817083820841.png" alt="image-20230817083820841"></p><h5 id="使用使用-REGEXP-和-NOT-REGEXP-操作符"><a href="#使用使用-REGEXP-和-NOT-REGEXP-操作符" class="headerlink" title="使用使用 REGEXP 和 NOT REGEXP 操作符"></a>使用使用 <code>REGEXP</code> 和 <code>NOT REGEXP</code> 操作符</h5><p>MySQL 还有一些扩展正则表达式，如下所示：</p><ul><li><code>^</code> 匹配输入字符串的开始位置。</li><li><code>$</code> 匹配输入字符串的结束位置。</li><li><code>{n}</code> 匹配确定的 n 次，这里的 n 必须是一个非负整数。</li></ul><p>MySQL 的正则表达式的匹配应用于 <code>REGEXP</code> 或者 <code>NOT REGEXP</code> 的操作符中。</p><p>查询以C开头的名字</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM pet WHERE name REGEXP '^C';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817084302727.png" alt="image-20230817084302727"></p><p>查询不以y结尾的名字</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM pet WHERE name NOT REGEXP 'y$';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817084347471.png" alt="image-20230817084347471"></p><p>查询包含两个ff字符的名字</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM pet WHERE name REGEXP 'f{2}';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817084417123.png" alt="image-20230817084417123"></p><p>MySQL 的 <code>REGEXP</code> 操作符是基于正则表达式的，所以可能会对性能产生一些影响，尤其在大型数据集上。</p><h4 id="2、COUNT-和-MAX-的使用"><a href="#2、COUNT-和-MAX-的使用" class="headerlink" title="2、COUNT 和 MAX 的使用"></a>2、COUNT 和 MAX 的使用</h4><h5 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h5><p>查询表中的总行数</p><pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(*) FROM pet;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817084918559.png" alt="image-20230817084918559"></p><p>按照动物的种类和性别来分组统计数量</p><pre class="line-numbers language-none"><code class="language-none">select species,sex,count(*) from pet group by species,sex;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817085139898.png" alt="image-20230817085139898"></p><h5 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h5><p>语法格式</p><p># 这里的别名是自定义的，用来标识你查询数据的意义</p><p> SELECT MAX(&lt;字段名&gt;) as &lt;别名&gt; FROM &lt;表名&gt;;</p><p>例如 </p><p># 查询表中最大年龄，将 largest_age 作为别名</p><pre class="line-numbers language-none"><code class="language-none">select MAX(age) as largest_age from pet;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817085437414.png" alt="image-20230817085437414"></p><p>查询某列最大值的语法格式:</p><p>SELECT &lt;字段名&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt;(SELECT MAX(&lt;字段名&gt;) FROM &lt;表名&gt;)</p><p>新建一张表</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE pet_shop (    id INT(10) PRIMARY KEY,    species CHAR(10),    name CHAR(20),    price DECIMAL(10, 2));-- 插入数据INSERT INTO pet_shop (id, species, name, price)VALUES    (1, 'Dog', 'Buddy', 250.00),    (2, 'Cat', 'Whiskers', 150.00),    (3, 'Dog', 'Rocky', 300.00),    (4, 'Cat', 'Mittens', 120.00),    (5, 'Cat', 'Luna', 180.00);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询一下 pet_shop 表中，价格最高的动物的种类、年龄、价格信息。</p><pre class="line-numbers language-none"><code class="language-none">SELECT species, name, priceFROM pet_shopWHERE price = (SELECT MAX(price) FROM pet_shop);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817090307083.png" alt="image-20230817090307083"></p><p>按组显示列最大值的语法格式为：</p><p>SELECT &lt;字段名&gt;,MAX(字段名) AS &lt;别名&gt; FROM &lt;表名&gt; GROUP BY &lt;字段名&gt;;</p><p>按动物的品种作为分组，查询每个品种中最高的价格。</p><pre class="line-numbers language-none"><code class="language-none">select species,MAX(price) AS largest_price from pet_shop group by species;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817090706259.png" alt="image-20230817090706259"></p><h4 id="3、用户变量的使用"><a href="#3、用户变量的使用" class="headerlink" title="3、用户变量的使用"></a>3、用户变量的使用</h4><p>为了便于使用，我们可以定义一个特定的变量来保存该值，这样的变量就是 MySQL 的用户变量了。在 <code>SELECT</code> 语句中设置临时变量，需要使用 <code>@</code> 开头，然后需要使用 <code>:=</code> 来进行赋值。</p><p>比如，我们把在 <code>pet_shop</code> 表中的最大价格赋值给用户变量 <code>max_price</code>，把最低价格赋值给用户变量 <code>min_price</code>。</p><pre class="line-numbers language-none"><code class="language-none">SELECT @max_price := MAX(price), @min_price := MIN(price) FROM pet_shop;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817091048825.png" alt="image-20230817091048825"></p><p>查询最高价格</p><pre class="line-numbers language-none"><code class="language-none">SELECT @max_price;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817091253080.png" alt="image-20230817091253080"></p><p>查询最高价格和最低价格的动物信息</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM pet_shopWHERE price IN (@max_price, @min_price);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817091305440.png" alt="image-20230817091305440"></p><h4 id="4、过滤重复数据"><a href="#4、过滤重复数据" class="headerlink" title="4、过滤重复数据"></a>4、过滤重复数据</h4><h5 id="BIT-COUNT-和-BIT-OR"><a href="#BIT-COUNT-和-BIT-OR" class="headerlink" title="BIT_COUNT 和 BIT_OR"></a>BIT_COUNT 和 BIT_OR</h5><h5 id="DISTINCT-的使用"><a href="#DISTINCT-的使用" class="headerlink" title="DISTINCT 的使用"></a>DISTINCT 的使用</h5><p>DISTINCT 的使用格式为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>page_view</code> 表中，以年和月进行分组，计算各月的访问天数，并取别名为 <code>days</code>，使用 <code>DISTINCT</code> 过滤掉重复的行数据，取别名为 <code>tmp</code></p><pre class="line-numbers language-none"><code class="language-none">SELECT year, month, COUNT(day) AS daysFROM (SELECT DISTINCT year, month, day FROM page_view) AS tmpGROUP BY year, month;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817092132106.png" alt="image-20230817092132106"></p><h4 id="5、AUTO-INCREMENT-的使用"><a href="#5、AUTO-INCREMENT-的使用" class="headerlink" title="5、AUTO_INCREMENT 的使用"></a>5、AUTO_INCREMENT 的使用</h4><p>在 MySQL 中 <code>AUTO_INCREMENT</code> 用于为表中的每条记录自动生成 <code>ID</code>，这使得表中的每条记录能够被唯一标识。</p><pre class="line-numbers language-none"><code class="language-none"># 创建一张名为 food 的数据表CREATE TABLE food(    # 将 id 设为中等大小，非空，自增模式    id MEDIUMINT NOT NULL AUTO_INCREMENT,    name CHAR(30) NOT NULL,    # 将 id 作为主键，唯一标识    PRIMARY KEY (id));# 添加了三条数据INSERT INTO food (name) VALUES ('dog_food'),('cat_food'),('fish_food');# 查看表中信息SELECT * FROM food;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>AUTO_INCREMENT</code> 默认是从 1 开始自增的，我们可在建表时用 <code>AUTO_INCREMENT=n</code> 来指定一个自增的初始值。</p><pre class="line-numbers language-none"><code class="language-none"># 创建一张名为 user 的数据表CREATE TABLE user(    # 将 id 设为中等大小，非空，自增模式    id MEDIUMINT NOT NULL AUTO_INCREMENT,    name CHAR(30) NOT NULL,    # 将 id 作为主键，唯一标识    PRIMARY KEY (id)    )AUTO_INCREMENT=2; # 以 2 开始编号# 添加数据INSERT INTO user (name) VALUES ('Jack'),('Rose'),('Ann');# 查看表中信息SELECT * FROM user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、Mysql的连接查询"><a href="#6、Mysql的连接查询" class="headerlink" title="6、Mysql的连接查询"></a>6、Mysql的连接查询</h4><p>连接查询是在两张表或者多张表上进行<strong>行匹配</strong>的操作。MySQL 数据库主要支持三种连接查询，分别是:</p><ul><li>内连接查询。</li><li>外连接查询。</li><li>交叉连接查询。</li></ul><h5 id="交叉连接查询。"><a href="#交叉连接查询。" class="headerlink" title="交叉连接查询。"></a>交叉连接查询。</h5><p>交叉连接查询（<code>CROSS JOIN</code>）是对两个表执行笛卡尔积，返回两个表中所有列的组合。若表 1 有 m 行数据，表 2 有 n 行数据，则这种方式的查询将会返回 <code>m*n</code> 行的表。</p><p>交叉连接的语法格式有以下两种，分别为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表<span class="token number">1</span><span class="token operator">&gt;</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表<span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>表<span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 创建一张员工表CREATE TABLE employee(    # 把员工的 id 设为主键    id int(4) PRIMARY KEY,    # 部门编号    dep_id int(4),    name varchar(12),    age int(4),    gender char(4),    salary int(10),    city varchar(20));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">INSERT INTO employee VALUE(1,11,'Zhang San',27,'M',9000,'Chengdu'),(2,12,'Li Ming',26,'M',7000,'Chengdu'),(3,11,'Wang Xi',25,'F',6000,'Chengdu'),(4,12,'Liu Lu',24,'F',5800,'Hangzhou'),(5,11,'Xiao Min',28,'M',15000,'Shanghai');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 创建部门信息表CREATE TABLE department(    dept_id int(4),    dept_name varchar(20),    score int(5));# 添加数据INSERT INTO department VALUE(11,'R&amp;D',90),(12,'OD',80),(13,'AD',85);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>作交叉连接查询</strong></p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM department CROSS JOIN employee;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817093042944.png" alt="image-20230817093042944"></p><p>交叉连接（Cross Join）是一种 SQL 查询操作，它将一个表的每一行与另一个表的每一行进行组合，产生的结果集包含两个表中所有可能的组合。交叉连接是一种比较少用到的查询类型，因为它会产生大量的结果行，特别是在涉及到大型表时。</p><p>交叉连接的主要用途是在某些情况下创建临时的组合，比如为了生成测试数据，或者在需要计算两个表的笛卡尔积时。但通常情况下，我们更常见的是使用其他类型的连接，如内连接、外连接、自然连接等，这些连接类型通常更具实际意义和用途。</p><p>例如，假设你有一个表 A 和一个表 B，它们分别包含产品和颜色。如果你想要获取所有可能的产品和颜色组合，你可以使用交叉连接。但在实际情况下，这种查询通常并没有太多实际意义，因为大多数情况下我们更关心的是与业务逻辑相关的数据关联。</p><p>总之，交叉连接在特定情况下可能有用，但在绝大多数实际的数据库查询中，其他类型的连接更常见和更有意义。</p><h5 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h5><p>内连接查询（<code>INNER JOIN</code>）是用户根据一些过滤条件来匹配表之间的数据。在逻辑查询的前三个阶段处理中，INNER JOIN 应有前两个阶段，即首先产生笛卡尔积的虚拟表，再按照过滤条件来进行数据匹配操作。</p><p>内连接的查询原理是从<strong>左表</strong>中取出每条数据与<strong>右表</strong>中的数据匹配。匹配原则为左表的这条记录和右表的记录满足相同条件，则匹配成功，查询保留此结果。</p><p><img src="https://doc.shiyanlou.com/courses/2404/1347963/b19d7de859508667e378dda713cbeb50-0" alt="30-21"></p><p>内连接分为两种查询方式：</p><ul><li>显式内连接，在查询语句中，用 <code>ON</code> 连接条件。</li><li>隐式内连接，在查询语句中，用 <code>WHERE</code> 连接条件。</li></ul><p>内连接的查询语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 显式内连接</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>左表<span class="token operator">&gt;</span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>右表<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>条件<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token comment"># 隐式内连接</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>左表<span class="token operator">&gt;</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>右表<span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，这里用 <code>employee</code> 和 <code>department</code> 表来练习显式内连接和隐式内连接的查询操作。</p><p>将 <code>department</code> 表取别名为 <code>d</code>,内联接 <code>employee</code> 表取别名为 <code>e</code>,查询这两张表中满足 <code>d.dept_id = e.dep_id</code> 这个条件的数据。注意，取别名的目的是为了简化查询语句的书写，你也可以不设置别名。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 显式内连接</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> department d <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> employee e <span class="token keyword">ON</span> d<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> e<span class="token punctuation">.</span>dep_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817100122072.png" alt="image-20230817100122072"></p><p>\</p><pre class="line-numbers language-none"><code class="language-none"># 隐式内连接 SELECT * FROM department d,employee e WHERE d.dept_id = e.dep_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817100234261.png" alt="image-20230817100234261"></p><pre class="line-numbers language-none"><code class="language-none"># 创建实习生表CREATE TABLE intern(    id int(4),    dept_id int(4),    name varchar(12),    age int(4),    gender char(4),    city varchar(20));# 插入数据INSERT INTO intern VALUE(1,11,'Li',20,'M','Chengdu'),(2,12,'Liu',22,'F','Hangzhou'),(3,13,'Wang',21,'M','Shanghai');# 查看表中数据SELECT * FROM intern;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三表内连接查询</p><pre class="line-numbers language-none"><code class="language-none"># 显示内连接SELECT * FROM department d INNER JOIN employee e ON d.dept_id = e.dep_idINNER JOIN intern i ON d.dept_id = i.dept_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 隐式内连接SELECT * FROM department d,employee e,intern i WHERE d.dept_id = e.dep_id AND d.dept_id = i.dept_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817100618101.png" alt="image-20230817100618101"></p><h5 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h5><p>外连接（<code>OUTER JOIN</code>）也是用户可以根据一些过滤条件来匹配表之间的数据。它与内连接的区别在于，通过 <code>OUTER JOIN</code> 查询，表中会保留未找到的数据。在 MySQL 数据库中支持两种外连接，如下所示。</p><p>左外连接（<code>LEFT OUTER JOIN</code>) 是以左表为主表。</p><p><img src="https://doc.shiyanlou.com/courses/2404/1347963/7410a20a2028a6f8b43603336779aa39-0" alt="30-22"></p><p>右外连接（<code>RIGHT OUTER JOIN</code>）是以右表为主表。</p><p><img src="https://doc.shiyanlou.com/courses/2404/1347963/cf7f3b4843b8b328e78560ceb1bded8d-0" alt="30-23"></p><p>左外连接的基本语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 左外连接</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>左表<span class="token operator">&gt;</span> <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>右表<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>左表<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>右表<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们用 <code>department</code> 表和 <code>intern</code> 表来尝试一下左外连接查询，这里将 <code>department</code> 表作为主表。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 左外连接</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> department d <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> intern i <span class="token keyword">ON</span> d<span class="token punctuation">.</span>dept_id <span class="token operator">=</span> i<span class="token punctuation">.</span>dept_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817101010424.png" alt="image-20230817101010424"></p><p>右外连接的基本语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 右外连接</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>左表<span class="token operator">&gt;</span> <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>右表<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>左表<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>右表<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们对 <code>employee</code> 表和 <code>intern</code> 表做一个右外连接查询，将 <code>employee</code> 表做为主表。</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM intern i RIGHT JOIN department d ON i.dept_id = d.dept_id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817101229366.png" alt="image-20230817101229366"></p><p>值得注意的是在左外连接中，无论右表是否匹配得上条件，查询结果都会被保留，若没匹配上条件，左表的字段都会置为 NULL；右外连接也是一样。</p><p>对 <code>intern</code> 表和 <code>employee</code> 表做一个右外连接，查询条件为 <code>intern</code> 表中的年龄大于 <code>employee</code> 表中的年龄。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> intern<span class="token punctuation">.</span>name<span class="token punctuation">,</span>employee<span class="token punctuation">.</span>name<span class="token keyword">FROM</span> intern <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> employee<span class="token keyword">ON</span> intern<span class="token punctuation">.</span>age <span class="token operator">&gt;</span> employee<span class="token punctuation">.</span>age<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817101456552.png" alt="image-20230817101456552"></p><p><strong>左外连接（Left Outer Join）</strong>：保留左边表（即左表）的所有行，同时将右边表中与左表匹配的数据行连接起来。如果在右表中没有匹配的数据行，仍然会返回左表中的数据，右表中的相应列将填充为 NULL。</p><p><strong>右外连接（Right Outer Join）</strong>：与左外连接类似，保留右边表（即右表）的所有行，同时将左边表中与右表匹配的数据行连接起来。如果在左表中没有匹配的数据行，仍然会返回右表中的数据，左表中的相应列将填充为 NULL。</p><h5 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h5><p>联合查询是将多个 <code>SELECT</code> 语句的查询结果合并到一起的查询。比如，我们想知道公司研发部和运营部，两个部门的员工信息，由于查询目的相同，都是想知道员工的信息，所以我们可以使用关键字 <code>UNION</code> 或者 <code>UNION ALL</code> 将查询结果合并。</p><p>联合查询的语法格式为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span><span class="token keyword">UNION</span><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如，我们联合查询 <code>employee</code> 表和 <code>intern</code> 表中的姓名和年龄信息。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> intern<span class="token punctuation">.</span>name<span class="token punctuation">,</span>intern<span class="token punctuation">.</span>age<span class="token keyword">FROM</span> intern<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> employee<span class="token punctuation">.</span>name<span class="token punctuation">,</span>employee<span class="token punctuation">.</span>age<span class="token keyword">FROM</span> employee<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817102651603.png" alt="image-20230817102651603"></p><p><code>UNION</code> 和 <code>UNION ALL</code> 的区别在于，<code>UNION</code> 会把多个查询语句合并后去掉重复的数据，而 <code>UNION ALL</code> 仅仅合并，不会去除重复数据。</p><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><p>子查询是将一个查询语句嵌套在另一个查询语句中。子查询中可以包含：<code>IN</code>、<code>NOT IN</code>、<code>ANY</code>、<code>ALL</code>、<code>EXISTS</code> 和 <code>NOT EXISTS</code> 等关键字。虽然子查询能够使查询变得简单，但由于它要对基础表中的每条数据都进行查询，所以当表中的数据过多时，不适合使用子查询。</p><p>若查询时，知道查询结果只包含一个值，可以直接使用比较运算符连接子查询。常用的比较运算符有 =、&lt;、&gt;、!=、&gt;=、&lt;=。</p><p>带比较运算符的子查询的语法格式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>比较运算符<span class="token operator">&gt;</span>（<span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，内层查询 <code>department</code> 表中，部门名称为 <code>OD</code> 的部门编号，再从 <code>employee</code> 表中查询属于这个部门的成员信息。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employee <span class="token keyword">WHERE</span> dep_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> dept_id <span class="token keyword">FROM</span> department <span class="token keyword">WHERE</span> dept_name <span class="token operator">=</span> <span class="token string">'OD'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817103959448.png" alt="image-20230817103959448"></p><p><code>EXISTS</code> 子查询是用来判断某些条件是否被满足。</p><p>其语法格式为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们查询从 <code>department</code> 表中的名为 <code>R&amp;D</code> 的部门 id 号是否存在于 <code>employee</code> 表中。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employee<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> dept_id <span class="token keyword">FROM</span> department <span class="token keyword">WHERE</span> dept_name <span class="token operator">=</span> <span class="token string">'R&amp;D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817104325196.png" alt="image-20230817104325196"></p><p>带 <code>ANY</code> 关键词的子查询是对于子查询返回列中的<strong>任一数值</strong>而言，若比较结果为真，则返回。也就是说，只要满足内层循环任意一个条件，便可以通过该条件来执行外层查询语句。<code>ANY</code> 关键词必须与一个比较操作符一起使用。</p><p>其语法结果为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>比较运算符<span class="token operator">&gt;</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表<span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">insert into intern values (4,12,'Li Qin',28,'M','Chengdu');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询一下，<code>intern</code> 表中年龄大于 <code>employee</code> 表中的行数据。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> intern<span class="token keyword">WHERE</span> age <span class="token operator">&gt;</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> age <span class="token keyword">FROM</span> employee<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817104609330.png" alt="image-20230817104609330"></p><h4 id="7、MySQL-的约束和索引"><a href="#7、MySQL-的约束和索引" class="headerlink" title="7、MySQL 的约束和索引"></a>7、MySQL 的约束和索引</h4><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><p>约束是插入和处理数据库数据的规则，用来保证数据库中数据的完整性。创建约束有以下两种方式：</p><ul><li>创建表时就给字段名定义约束。</li><li>使用 <code>ALTER TABLE</code> 命令来创建约束。</li></ul><p>约束的种类很多，在本节实验中，我们会学习几种常用的约束的使用，分别是主键约束、外键约束、唯一约束、检查约束以及默认值约束。</p><h6 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h6><p>主键约束（<code>PRIMARY KEY</code>）：用来建立表的主键，是表中每一条记录的标识符，被确定为主键的字段名必须是非空并且主键列上不能有相同的值。主键可以定义一个字段名或者多个字段名，定义多个字段名的主键叫做复合主键。</p><p>主键约束的创建有以下两种格式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 建表时，创建主键</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>（    <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 建表后，添加主键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span> <span class="token keyword">MODIFY</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>字段类型<span class="token operator">&gt;</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 建表时，创建主键CREATE TABLE info1(    # 设置 id 为主键    id int(4) PRIMARY KEY,    name varchar(20));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 将 department 表中的 dept_id 字段名设为主键ALTER TABLE department MODIFY dept_id int(4) PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 删除主键ALTER TABLE department DROP PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h6><p>唯一约束（<code>UNIQUE</code>）：在设置字段名为唯一约束后，这列数据不能重复，但允许存在空值，可以设多列为唯一约束，但是主键所在的列不能设置为 <code>UNIQUE</code>。</p><p>唯一约束的创建格式有以下两种：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 建表时，创建唯一约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>（    <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 建表后，添加唯一约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span> <span class="token keyword">MODIFY</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>字段类型<span class="token operator">&gt;</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，我们在这个数据库中，创建一张名为 <code>info2</code> 的表来练习设置唯一约束。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建一张名为 info2 的表，将字段 name 设为唯一约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> info2<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 将 info2 表中的 id 字段名创建唯一约束ALTER TABLE info2 MODIFY id int(4) UNIQUE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 删除唯一约束ALTER TABLE info2 DROP INDEX id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE TABLE &lt;表名&gt;  #查看所有约束<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h6><p>检查约束（<code>CHECK</code>） ：是保证一列的数据满足指定的条件，它通过限制输入到列中的值来强制域的完整性。但目前 MySQL 版本只是对 CHECK 约束进行了分析处理，会被直接忽略掉，并不会报错。</p><p>检查约束的创建格式为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 建表时，创建检查约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>（    <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span><span class="token punctuation">,</span>    <span class="token keyword">CHECK</span> <span class="token operator">&lt;</span>检查约束条件<span class="token operator">&gt;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 建表后，添加检查约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>数据表名<span class="token operator">&gt;</span> <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> <span class="token operator">&lt;</span>检查约束名<span class="token operator">&gt;</span> <span class="token keyword">CHECK</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>检查约束条件<span class="token operator">&gt;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，我们创建一张名为 <code>info3</code> 的表，在表中对年龄设置检查约束，约束年龄在 18 岁到 30 岁之间。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> info3<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    score <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    age <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">CHECK</span> <span class="token punctuation">(</span>age <span class="token operator">&gt;</span> <span class="token number">18</span> <span class="token operator">and</span> age <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817105701540.png" alt="image-20230817105701540"></p><p>从图中可以看出，我们插入的这条数据的年龄值并不符合要求，但还是能被添加到表中而且没有报错。同学们到这里可能觉得检查约束并没有什么用。其实我们可以使用触发器来实现检查约束的功能。触发器实际应用不多，这里就不详细介绍了，感兴趣的同学可以看看这篇文章，<a href="https://blog.csdn.net/pan_junbiao/article/details/86241390">MySQL 使用触发器实现 CHECK 检查约束功能</a>。</p><pre class="line-numbers language-none"><code class="language-none"># 在 info3 表中的 score 添加检查约束，约束条件为分数大于 50ALTER TABLE info3 ADD CONSTRAINT score_check CHECK(score &gt; 50);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="默认值约束"><a href="#默认值约束" class="headerlink" title="默认值约束"></a>默认值约束</h6><p>默认值约束（<code>DEFAULT</code>）：是用于在进行插入操作时，如果某一列没有值，系统会自动把之前设置的默认值赋值到该列。</p><p>默认值约束的创建格式有以下两种：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 在建表时，创建默认值约束</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span> <span class="token keyword">DEFAULT</span> <span class="token operator">&lt;</span>默认值<span class="token operator">&gt;</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 在建表后，添加默认值约束</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span> <span class="token keyword">MODIFY</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>字段类型<span class="token operator">&gt;</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">VALUE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，我们创建一张名为 <code>info4</code> 的表，在里面添加默认约束。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建表同时给 gender 字段创建默认值约束，默认值为 Female</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> info4<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    gender <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">'Female'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token comment"># 查看表中信息</span><span class="token keyword">DESCRIBE</span> info4<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817105846132.png" alt="image-20230817105846132"></p><h6 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h6><p>外键约束（<code>FOREIGN KEY</code>）：是表中的一列，其值必须列在另一表的主键中。外键约束有以下三种：</p><ul><li>严格模式：被子表用的记录不能被父表删除或更新。</li><li>级联模式：父表改变，子表也跟着改变。</li><li>置空模式：父表改变，子表对应的字段会被置空。</li></ul><p>设置外键约束，保证两张表之间具有父子关系，也就是说子表外键的取值范围由父表决定，子表外键的数据类型要与父表一致。</p><p>创建外键的格式有以下两种：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建表时，建立外键</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表<span class="token number">1</span><span class="token operator">&gt;</span>（    <span class="token operator">&lt;</span>字段名<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表<span class="token number">2</span><span class="token operator">&gt;</span>（    <span class="token operator">&lt;</span>字段名<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># 外键字段名2 参照表1 中的字段名1</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>字段名<span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> <span class="token operator">&lt;</span>表<span class="token number">1</span><span class="token operator">&gt;</span>（<span class="token operator">&lt;</span>字段名<span class="token number">1</span><span class="token operator">&gt;</span>）<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 创建表后，添加外键</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token number">1</span><span class="token operator">&gt;</span> <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span><span class="token operator">&lt;</span>外键名<span class="token operator">&gt;</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token operator">&lt;</span>外键字段名<span class="token operator">&gt;</span> <span class="token keyword">REFERENCES</span> <span class="token operator">&lt;</span>表名<span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>主键字段名<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，我们在数据库中创建两张表，一张名为 <code>class</code> 的表，一张名为 <code>student</code> 的表，在创建第二张表中创建外键约束。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> class<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student<span class="token punctuation">(</span>    stu_id <span class="token keyword">int</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    stu_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    score <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    class_id <span class="token keyword">int</span><span class="token punctuation">,</span>    <span class="token comment"># student 表中的 class_id 将参考 class 表中的 id</span>    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>class_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> class<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时的 <code>class</code> 表为父表，而 <code>student</code> 表为子表。若我们对父表的主键字段进行删和改时，如果对应的主键在子表中被引用，操作就会失败。</p><p><img src="https://doc.shiyanlou.com/courses/2404/1347963/d99b0bde462b6cc93c6e88b307825e52-0" alt="40-16"></p><p>值得注意的是外键约束必须是在 InnoDB 存储引擎中才起作用。此外，使用外键会降低数据库的速度，所以尽量不要使用。</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>索引是存储引擎用于快速找到记录的一种数据结构，在 MySQL 中也叫做键，用来排序数据以加快搜索和排序操作的速度。这就像图书馆里的每本书都有自己的编号一样，如果图书馆里的书没有编号也没有分类，那我们要找到一本书，会花很长时间。而每本书拥有自己唯一的编号，我们只需要在对应编号的书架上查找该书。所以，索引的出现是为了提高查询速度。</p><p>索引按数据结构分类，常见的有以下三种：</p><ul><li>哈希索引（<code>HASH</code>）：是基于哈希实现的，只有精确匹配索引的所有列的查询才有效。</li><li>B-Tree 索引（<code>BTREE</code>）：是索引的值按照顺序存储。</li><li>R-Tree 空间数据索引（<code>RTREE</code>）：是 MyISAM 表支持空间数据索引，可以用作地理数据存储。</li></ul><p>常见的索引种类有以下几种：</p><ul><li>普通索引（<code>INDEX</code>）：最基本的索引，没有任何限制，仅加速查询。</li><li>唯一索引（<code>UNIQUE</code>）：是索引列的值必须唯一，但允许有空值。</li><li>主键索引（<code>PRIMARY KEY</code>）：是一种特殊的唯一索引，它不允许有空值。</li><li>全文索引（<code>FULLTEXT</code>）：是对文本的内容进行分词，进行搜索。</li></ul><h6 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h6><p>普通索引的创建方法如下所示：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 直接创建索引</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们使用之前实验所建立的 <code>company</code> 数据库，在数据库中有一张名为 <code>employee</code> 的表，我们给表中的 <code>name</code> 字段创建一个普通索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 给表中的 name 字段名创建一个名为 idx_id_name 的索引</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_id_name <span class="token keyword">ON</span> employee<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#查看索引SHOW INDEX FROM employee;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 修改表结构的方式添加索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们再向 <code>employee</code> 表中的 <code>id</code> 字段名添加一个名为 <code>idx_id</code> 的索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> employee <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> idx_id <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建表的同时创建一个索引</p><pre class="line-numbers language-none"><code class="language-none"># 创建表时，并创建一个名为 idx_id 的索引CREATE TABLE t(    id int NOT NULL,    name varchar(12),    INDEX idx_id (id));# 查看索引信息SHOW INDEX FROM t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 删除名为 t 的索引DROP INDEX idx_id ON t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h6><p>唯一索引与普通索引的区别在于，唯一索引是查到符合条件的项后就直接返回，而普通索引是查到符合条件的项后会继续查找下一项，若下一项不符合再返回。</p><p>创建唯一索引的方式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建唯一索引</span><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">&gt;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，我们在刚才创建的 <code>t</code> 表中创建一个名为 <code>idx_uni_id</code> 的唯一索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> idx_uni_id <span class="token keyword">ON</span> t <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 修改表结构创建唯一索引ALTER TABLE &lt;表名&gt; ADD UNIQUE &lt;索引名&gt;（&lt;列名&gt;）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE t ADD UNIQUE idx_uni_name (name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 建表时,创建唯一索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">UNIQUE</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，创建一张名为 <code>t1</code> 的表，并且在建表时建立唯一索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1<span class="token punctuation">(</span>    id <span class="token keyword">int</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> idx_uni_id <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p>主键索引必须唯一，并且非空。</p><p>创建主键索引的方式如下所示：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建表后，添加主键索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span> <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，在 <code>t1</code> 表中，给字段 <code>id</code> 添加一个主键索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 在 t1 表中添加主键索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t1 <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment"># 查看索引信息</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> t1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 删除主键索引ALTER TABLE t1 DROP PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建表时，建立主键索引</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>字段名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>数据类型<span class="token operator">&gt;</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如，创建一张名为 <code>t2</code> 的表，并给字段名 <code>id</code> 添加一个索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t2<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h6><p><em>非重点</em></p><h4 id="8、MySQL-权限"><a href="#8、MySQL-权限" class="headerlink" title="8、MySQL 权限"></a>8、MySQL 权限</h4><p>在实际应用中，为了防止因操作不当，导致数据被误删。所以，一般不会直接在 root 用户下直接进行数据库的操作，我们通常会登录 root 账户后，创建一些新用户并赋予这些用户一些操作数据库的权限。</p><p>MySQL 的用户权限可分为三大级别：</p><ul><li>全局性的管理权限：作用于整个 MySQL 实例级别。</li><li>数据库级别的权限：作用于某个指定的或者所有的数据库上。</li><li>数据库对象级别的权限：作用于指定单个数据库对象，如表、视图等，或者所有的数据库对象上。</li></ul><p>账户权限信息被存储在 MySQL 数据库中的 <code>user</code>，<code>db</code>，<code>host</code>，<code>tables_priv</code>，<code>columns_priv</code>，<code>procs_priv</code> 这几个系统表中。接下来为大家简单介绍一下这几个表的作用吧。</p><ul><li><code>user</code> 表：记录允许连接到服务器的账户信息。</li><li><code>db</code> 表：记录用户对某个数据库操作的权限信息。</li><li><code>host</code> 表：记录主机上的用户对数据库拥有的权限信息。</li><li><code>tables</code> 表：记录用户对某个表的操作权限信息。</li><li><code>columns_priv</code>表：记录用户对表里的某一列的操作权限信息。</li><li><code>procs_priv</code> 表：记录用户对存储过程和存储函数的操作权限信息。</li></ul><p>首先介绍一下账户操作的基本命令：</p><ul><li><code>-h</code> 为主机名，默认是 localhost。</li><li><code>-u</code> 为用户名。</li><li><code>-p</code> 为登录密码。</li></ul><p>查看表中有哪些用户</p><pre class="line-numbers language-none"><code class="language-none">SELECT user,host FROM mysql.user;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看user表中所有用户信息</p><pre class="line-numbers language-none"><code class="language-none"># 查看 user 表中所有信息SELECT * FROM mysql.user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个语句的基础上加一个 <code>WHERE</code> 条件语句可用来查看单一用户权限：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">user</span><span class="token operator">=</span>'<span class="token operator">&lt;</span>用户名<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们查看一下 <code>root</code> 用户的权限信息。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span> <span class="token keyword">WHERE</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 MySQL 中常用的添加用户的语句，有以下两种方式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'&lt;新用户的账户&gt;'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'&lt;用户密码&gt;'</span><span class="token punctuation">;</span><span class="token comment"># *.* 表示对所有数据库生效</span><span class="token comment"># 这里的主机号就是 ip 地址</span><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>权限<span class="token operator">&gt;</span> <span class="token keyword">on</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户名<span class="token operator">&gt;</span><span class="token variable">@'&lt;主机号&gt;'</span>IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'&lt;密码&gt;'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>CREATE USER</code> 来创建用户，相当于在 <code>user</code> 表中添加一条新的记录，用户是没有任何权限的，我们需要其他操作来授予权限给用户，而使用 <code>GRANT</code> 语句在创建用户的同时给用户授权。</p><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><p>例如，我们添加一个用户名为 <code>Lotus</code> 的新用户账号，其密码为 123。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 创建新用户</span><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'Lotus'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'123'</span><span class="token punctuation">;</span><span class="token comment"># 查看用户信息</span><span class="token keyword">SELECT</span> <span class="token keyword">user</span><span class="token punctuation">,</span>host <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h5><p>对于已经存在的用户，我们也可以进行修改，语句格式如下所示：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> <span class="token string">'&lt;旧用户名&gt;'</span><span class="token variable">@'&lt;旧主机号&gt;'</span> <span class="token keyword">TO</span> <span class="token string">'&lt;新用户名&gt;'</span><span class="token variable">@'&lt;新主机号&gt;'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们修改 <code>Lotus</code> 用户的用户名和 <code>ip</code> 地址。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">RENAME</span> <span class="token keyword">USER</span> <span class="token string">'Lotus'</span><span class="token variable">@'%'</span> <span class="token keyword">TO</span> <span class="token string">'Li'</span><span class="token variable">@'localhost'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不想要该用户了，我们可以使用以下两种删除语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token string">'&lt;用户名&gt;'</span><span class="token variable">@'&lt;主机名&gt;'</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host<span class="token operator">=</span><span class="token string">'&lt;主机名&gt;'</span> <span class="token operator">AND</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'&lt;用户名&gt;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如，我们把刚才创建的 <code>Cici</code> 用户给删除了。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token string">'Cici'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在我们使用第二种方法把 <code>Lotus</code> 用户也删除了。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span> <span class="token keyword">WHERE</span> Host<span class="token operator">=</span><span class="token string">'%'</span> <span class="token operator">AND</span> <span class="token keyword">User</span><span class="token operator">=</span><span class="token string">'Lotus'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="限制账户资源"><a href="#限制账户资源" class="headerlink" title="限制账户资源"></a>限制账户资源</h5><p>要限制用户资源，首先我们要先了解一下 MySQL 的资源列。常见的资源列有以下几种：</p><ul><li><code>max_questions</code>：用户每小时允许执行的查询操作次数。</li><li><code>max_updates</code>：用户每小时允许执行更新操作次数。</li><li><code>max_connections</code>：用户每小时允许执行的连接操作次数。</li><li><code>max_user_connections</code>：用户允许同时建立的连接次数。</li></ul><p>限制客户端使用 MySQL 服务器资源的一种方法是将全局 <code>MAX_USER_CONNECTIONS</code> 系统变量设置为非零值，这会限定账号建立同时连接的数量。</p><p>例如，我们重新建立一个名为 <code>Lotus</code> 的用户，并对该用户进行资源限制。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 在创建账户之后进行资源限制</span><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> Lotus<span class="token punctuation">.</span><span class="token operator">*</span><span class="token keyword">TO</span> <span class="token string">'Lotus'</span><span class="token variable">@'%'</span><span class="token keyword">WITH</span> MAX_QUERIES_PER_HOUR <span class="token number">3</span>MAX_USER_CONNECTIONS <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以使用 <code>ALTER USER</code> 语句来修改现有的资源。例如，我们把用户 <code>Lotus</code> 的资源限制信息进行修改，把用户在一个小时内的执行查询的次数从 3 次修改为 50 次。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'Lotus'</span><span class="token variable">@'%'</span> <span class="token keyword">WITH</span> MAX_QUERIES_PER_HOUR <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以在创建账户时，进行资源限制。例如，我们再创建一个名为 <code>Ann</code> 的用户。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'Ann'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'123'</span><span class="token comment"># 设置用户在一小时内可以执行 20 次查询</span><span class="token keyword">WITH</span> MAX_QUERIES_PER_HOUR <span class="token number">20</span><span class="token comment"># 设置用户在一小时内可以修改 20 次</span>MAX_UPDATES_PER_HOUR <span class="token number">20</span><span class="token comment"># 设置用户在一小时内可以连接 MySQL 5 次</span>MAX_CONNECTIONS_PER_HOUR <span class="token number">5</span><span class="token comment"># 设置所有用户在同一时间连接 MySQL 的最大连接数为 5</span>MAX_USER_CONNECTIONS <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以使用下面的方式来查看自己设定的用户权限。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">user</span><span class="token punctuation">,</span>host<span class="token punctuation">,</span>u<span class="token punctuation">.</span>max_questions<span class="token punctuation">,</span>u<span class="token punctuation">.</span>max_updates<span class="token punctuation">,</span>u<span class="token punctuation">.</span>max_connections<span class="token punctuation">,</span>u<span class="token punctuation">.</span>max_user_connections <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span> u <span class="token keyword">WHERE</span> u<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token operator">=</span><span class="token string">'Ann'</span>\G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="设置账户密码"><a href="#设置账户密码" class="headerlink" title="设置账户密码"></a>设置账户密码</h5><p>修改用户密码常用的有以下两种方式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> <span class="token string">'&lt;用户名&gt;'</span><span class="token variable">@' &lt;主机号&gt;'</span><span class="token operator">=</span>PASSWORD<span class="token punctuation">(</span><span class="token string">'&lt;新密码&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">USAGE</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'&lt;用户名&gt;'</span><span class="token variable">@'&lt;主机号&gt;'</span>IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'&lt;新密码&gt;'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如，我们把 <code>Ann</code> 账户的密码修改为 Ann。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> PASSWORD <span class="token keyword">FOR</span> <span class="token string">'Ann'</span><span class="token variable">@'%'</span><span class="token operator">=</span>PASSWORD<span class="token punctuation">(</span><span class="token string">'Ann'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我们把 <code>Ann</code> 账户的密码再次修改，使用第二种方式把密码修改为 777。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">USAGE</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'Ann'</span><span class="token variable">@'%'</span>IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'777'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h4><p>事务可由简单或者复杂的 <code>SQL</code> 语句组成，事务是访问并更新数据库中各种数据项的一个程序执行单元。事务是数据库区别于文件系统的重要特性之一。它用于处理操作量大和复杂度高的数据。事务必须同时满足 ACID 四个条件：原子性（<code>Atomicity</code>）、一致性（<code>Consistency</code>）、隔离性（<code>Isolation</code>）、持久性（<code>Durability</code>）。</p><ul><li>原子性：事务中所有的操作，要么全部执行，要么全不执行，若中途发生异常，会回滚。</li><li>一致性：事务从开始到结束，数据库都具有完整性，这是对数据库层面和应用层面的双重保障。</li><li>隔离性：用来保证多个并发事务对数据进行操作，不会发生受到干扰。</li><li>持久性：用来保证事务提交后，对数据的修改具有永久性。</li></ul><p>引入事务的目的是为了保障关系型数据库中的数据一致，提高查询数据的可靠性。隔离性是事务的一个很重要的特性，它用来保证事务之间互不打扰。由于在事务中执行 SQL 语句，我们不能避免其他事务开始执行，所有我们需要隔离机制来保证不同事务之间不被打扰。事务的隔离是由 MySQL 的锁机制来实现的，在下一节实验中会详细讲解，这里就先提一下。</p><p>对于 MySQL 来说，常会受到读写并发问题的困扰。想象一下，当你正在数据库里查询一些信息，这时一个管理员正在修改这个数据库，而你可能访问两次同一个数据库查询到的结果是不同的，这时你会觉得这个数据库里的数据可靠性很低。常见的并发问题主要有以下三类：</p><ul><li>脏读：当前事务读到其他事务未提交的数据。</li><li>幻读：事务 1 按照某个条件多次查询数据库，但每次查询的结果行数不同。</li><li>不可重复读：事务 1 多次读取同一数据资源，与此同时事务 2 对该数据进行了多次修改，这导致事务 1 每次读取的数据显示结果不同。</li></ul><p>根据上面三种并行问题，产生了下面四种隔离级别。现在的 MySQL 默认的事务隔离级别为 <code>REPEATABLE-READ</code>，完全遵循和满足事务的 <code>ACID</code> 特性。</p><p>在 MySQL 中，事务的隔离级别分为以下四种：</p><ul><li>读未提交（<code>READ-UNCOMMITTED</code>）：可能发生脏读、可幻读和不可重复读。</li><li>读已提交（<code>READ-COMMITTED</code>）：可能发生幻读、不可重复读，不可能发生脏读。</li><li>可重复读（<code>REPEATABLE-READ</code>）：可能发生幻读，但不会发生脏读和不可重复读。</li><li>串行化（<code>SERIALIZABLE</code>）：不可能发生幻读、脏读、可重复读。</li></ul><p>了解了事务的隔离级别，现在我们使用下面这句命令来查看一下 MySQL 的默认隔离级别吧。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 查看 MySQL 的默认隔离级别</span><span class="token keyword">SELECT</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230817121839725.png" alt="image-20230817121839725"></p><p>从事务理论的角度来看，可以把事务分为以下几种：</p><ul><li>扁平事务（<code>Flat Transactions</code>）：所有操作处于同一层次，要么都执行，要么回滚。</li><li>带有保存点的扁平事务（<code>Flat Transactions with Savepoints</code>）：保存点是用来通知系统应该记住事务当前的状态，以便在发生错误时，可以回滚到保存点的状态。</li><li>链事务（<code>Chained Transactions</code>）：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传递给下一个开始事务，下一个事务会看到上一个事务的结果。</li><li>嵌套事务（<code>Nested Transactions</code>）：是一个层次结构的框架，由一个顶层事务控制着各个层次的事务，顶层之下的事务称为子事务，子事务控制着每一个局面的变化。</li><li>分布式事务（<code>Distributed Transactions</code>）：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在的位置访问网络中的不同节点。</li></ul><blockquote><p>值得注意的是，带有保存点的扁平事务和链事务都能回滚，不同的是，带有保存点的扁平事务可以回滚到任意正确的保存点，而链事务只能回滚到最近的一个保存点。对于 <code>InnoDB</code> 存储引擎来说，并不支持嵌套事务，但用户可以通过带有保存点的事务来模拟串行嵌套事务。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股</title>
      <link href="/2023/08/16/ba-gu/"/>
      <url>/2023/08/16/ba-gu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h4><h5 id="1、B树和B-树的区别-为什么Mysql使用B-树"><a href="#1、B树和B-树的区别-为什么Mysql使用B-树" class="headerlink" title="1、B树和B+树的区别  为什么Mysql使用B+树"></a>1、B树和B+树的区别  为什么Mysql使用B+树</h5><p>区别：</p><p>B树是一种多路平衡搜索树，B树在<strong>每个节点既存储数据，又存储子节点的指针</strong>，因此可以在查找时直接定位到数据。B树通常用于文件系统等需要<strong>随机访问</strong>的场景。</p><p>B+树也是一种<strong>平衡多路搜索树</strong>，与B树不同的是，<strong>B+树的非叶子节点只存储键值，而不存储数据</strong>，所有数据都存储在叶子节点上，叶子节点之间使用链表连接。</p><p>原因</p><p>B+树适用于<strong>范围查询</strong>和<strong>顺序遍历</strong>，同时可以<strong>减少树的高度</strong>，<strong>减少磁盘的I/O次数</strong>。</p><h5 id="2、Innodb是如何实现事务的"><a href="#2、Innodb是如何实现事务的" class="headerlink" title="2、Innodb是如何实现事务的"></a>2、Innodb是如何实现事务的</h5><p>InnoDB使用<strong>MVCC（多版本并发控制）</strong>、<strong>Undo（回滚）日志</strong>、Redo（撤销日志）和 <strong>锁</strong> 等多种机制来实现事务的隔离性、一致性和持久性，以保证数据库的安全性和稳定性。</p><h5 id="3、Explain语句的作用"><a href="#3、Explain语句的作用" class="headerlink" title="3、Explain语句的作用"></a>3、Explain语句的作用</h5><p>“EXPLAIN” 是 MySQL 数据库中的一个关键字，用于<strong>分析查询语句的执行计划</strong>。通过使用 “EXPLAIN” 关键字，你可以查看 MySQL 是如何执行给定的查询语句的，以及查询涉及的表、索引、连接和优化过程等信息。这对于优化查询性能和理解查询执行过程非常有用。</p><h5 id="4、Mysql慢查询如何优化"><a href="#4、Mysql慢查询如何优化" class="headerlink" title="4、Mysql慢查询如何优化"></a>4、Mysql慢查询如何优化</h5><p>1、检查查询是否走了索引，没有索引可以<strong>建立索引</strong></p><p>2、查询有索引可以<strong>优化索引</strong></p><p>3、可以<strong>优化查询语句</strong>，查看语句是否查询了不必要的字段</p><p>4、如果数据库中数据过多，可以进行<strong>分表</strong></p><h5 id="5、如何实现分库分表"><a href="#5、如何实现分库分表" class="headerlink" title="5、如何实现分库分表"></a>5、如何实现分库分表</h5><p>水平分割：<strong>将数据分散到多张表</strong></p><p>垂直分割：<strong>拆分字段、需要重构</strong></p><h5 id="6、存储拆分后如何解决唯一主键问题"><a href="#6、存储拆分后如何解决唯一主键问题" class="headerlink" title="6、存储拆分后如何解决唯一主键问题"></a>6、存储拆分后如何解决唯一主键问题</h5><p><strong>使用UUID</strong></p><p><strong>使用数据库主键</strong></p><p><strong>使用一些中间件如Zookkper Redis</strong></p><h5 id="7、Mysql的集群是如何搭建的-读写分离是怎么做的"><a href="#7、Mysql的集群是如何搭建的-读写分离是怎么做的" class="headerlink" title="7、Mysql的集群是如何搭建的  读写分离是怎么做的"></a>7、Mysql的集群是如何搭建的  读写分离是怎么做的</h5><p><strong>主从复制（Master-Slave Replication）：</strong> 这是一种常见的 MySQL 集群搭建方式。在主从复制中，有一个<strong>主节点</strong>（Master）和<strong>一个或多个从节点</strong>（Slave）。<strong>主节点负责处理写操作</strong>（INSERT、UPDATE、DELETE），然后将写操作的日志传播到从节点，从节点将这些操作应用到自己的数据上，从而保持数据的一致性。主从复制主要用于分担读写压力和提高系统的冗余性。</p><p>读写分离的目标是将<strong>读操作分发到从节点，而将写操作集中在主节点</strong>。</p><p>在主从复制中，从节点可以处理读操作，<strong>因为从节点是主节点的一个复制，数据是一致的</strong>。但要注意，从节点上的数据可能会稍有滞后，所以适用于对实时性要求不高的读操作。</p><h5 id="8、RDB和AOF机制"><a href="#8、RDB和AOF机制" class="headerlink" title="8、RDB和AOF机制"></a>8、RDB和AOF机制</h5><p>RDB（Redis Database）和AOF（Append Only File）是Redis持久化机制，用于将内存中的数据保存到硬盘，以便在Redis重启后能够恢复数据。</p><p>RDB是一种<strong>快照（Snapshot）持久化</strong>方式（将某个节点的数据完整保存在磁盘）</p><p>AOF是一种<strong>日志持久化</strong>方式（追加写入AOF文件中）</p><p><strong>优先使用AOF  因为更好的提供数据完整性</strong></p><p><strong>但是RDB小  运行效率更高  AOF相反</strong></p><h5 id="9、Redis的过期键的删除策略"><a href="#9、Redis的过期键的删除策略" class="headerlink" title="9、Redis的过期键的删除策略"></a>9、Redis的过期键的删除策略</h5><p>1、<strong>定期删除</strong>  ：<strong>系统会在定期时间内对过期键进行删除</strong></p><p><strong>定期删除策略的缺点是可能会导致过期键堆积，因为它只是以一定的频率进行检查和删除，并不能保证所有过期键都会及时被删除。</strong></p><p>2、<strong>惰性删除</strong> ： 客户端<strong>请求访问某个键时，Redis会先检查这个键是否过期，如果过期则会立即删除。</strong></p><p><strong>惰性删除也有一些缺点。因为删除操作是在请求时进行的，如果过期键很久没有被访问，那么它就会一直存在于内存中，占据内存空间，直到有请求访问到它并触发删除操作。</strong></p><h5 id="10、redis线程模型-单线程为什么快"><a href="#10、redis线程模型-单线程为什么快" class="headerlink" title="10、redis线程模型  单线程为什么快"></a>10、redis线程模型  单线程为什么快</h5><p>快的核心：<strong>纯内存操作</strong></p><p><strong>核心是基于非阻塞的IO多路复用机制</strong></p><p><strong>单线程避免了多线程的频繁上下文切换带来的性能问题</strong></p><p><strong>I/O多路复用是一种同时监听多个I/O事件的机制。在传统的阻塞I/O模型中，一个线程只能处理一个I/O请求，当有新的请求到来时，线程会阻塞等待直到请求处理完成。而在I/O多路复用模型中，一个线程可以同时监听多个I/O事件，当有任何一个事件准备就绪时，线程会被通知，然后可以处理相应的事件。</strong></p><h4 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h4><h5 id="1、简述redis的事务实现"><a href="#1、简述redis的事务实现" class="headerlink" title="1、简述redis的事务实现"></a>1、简述redis的事务实现</h5><p>在 Redis 中，事务是一种将<strong>多个命令打包在一起执行的机制</strong>，可以保证这些命令<strong>要么全部执行成功，要么全部不执行</strong>。Redis 的事务实现基于 <strong>MULTI、EXEC、DISCARD 和 WATCH</strong> 四个命令。</p><ol><li><strong>MULTI</strong>：事务的开始，通过发送 MULTI 命令告知 Redis 开始记录接下来的一系列命令。</li><li><strong>命令入队</strong>：在 MULTI 和 EXEC 之间的命令都会被入队，而不是立即执行。这些命令不会立即改变数据库状态，而是被缓存起来。</li><li><strong>EXEC</strong>：当客户端发送 EXEC 命令时，Redis 会执行之前缓存在队列中的所有命令。如果在执行过程中没有发生错误，那么事务中的所有命令会被一起执行。如果出现错误，比如 WATCH 命令设置的监视键被修改，整个事务会被放弃，不会有任何命令被执行。</li><li><strong>DISCARD</strong>：如果在 MULTI 和 EXEC 之间执行了 DISCARD 命令，那么事务会被取消，之前缓存的所有命令都会被清除。</li><li><strong>WATCH</strong>：WATCH 命令用于监视一个或多个键，如果这些键在事务执行期间被其他客户端修改，那么事务将被放弃。这是一种乐观锁机制，用于处理并发情况。</li></ol><p>总结：Redis 的事务机制实际上是一种<strong>将一系列命令进行打包并保证原子性执行的机制</strong>。然而，需要注意的是，Redis 的事务不支持回滚操作，因此在使用事务时需要特别小心，确保事务内的命令逻辑是正确且不会引发问题的。事务主要用于将多个命令分组以便原子性地执行，但并不像关系型数据库中的事务那样提供隔离性和回滚功能。</p><p><strong>MULTI事务开始/EXCE 事务执行/DISCARD 事务取消/WATCH 事务监听/</strong></p><h5 id="2、redis集群方案"><a href="#2、redis集群方案" class="headerlink" title="2、redis集群方案"></a>2、redis集群方案</h5><p><strong>哨兵模式</strong>（主从模式）</p><p><strong>Redis Cluster</strong>：Redis Cluster是Redis官方提供的集群方案，它是一个分布式系统，使用哈希槽（hash slot）来将数据分片存储在多个节点上。</p><p>（主要是使用hash算法来实现）</p><p><strong>Redis sharing</strong></p><h5 id="3、redis主从复制的核心原理"><a href="#3、redis主从复制的核心原理" class="headerlink" title="3、redis主从复制的核心原理"></a>3、redis主从复制的核心原理</h5><ol><li><strong>建立连接</strong>：从节点与主节点建立网络连接。从节点通过发送SYNC命令请求与主节点进行复制。</li><li><strong>主节点快照</strong>：在进行<strong>全量复制</strong>之前，主节点会创建一个快照（RDB文件）包含当前数据库的数据，并将快照发送给从节点。快照是数据库的静态副本，用于初始化从节点。</li><li><strong>增量复制</strong>：一旦从节点接收到主节点的快照，它会继续请求主节点发送在快照之后所做的所有写操作。主节点会将这些写操作的命令发送给从节点，从节点执行这些写操作来保持与主节点数据的同步。</li><li><strong>命令传播</strong>：主节点会将自己接收到的写操作命令发送给所有连接的从节点，以保持它们的数据一致。</li><li><strong>心跳机制</strong>：从节点会周期性地向主节点发送PING命令来检查主节点是否可用。如果主节点无法响应，从节点将尝试连接其他可用的主节点。</li></ol><p><strong>主从复制的核心机制是通过发送命令和传播写操作，保持从节点数据与主节点一致。从节点定期与主节点进行通信，确保数据同步，并在主节点故障时切换到其他可用的主节点，以保持高可用性。</strong></p><p>/发送命令和传播写操作/保持从节点数据与主节点<strong>数据一致</strong>   /从节点定期与主节点通信/确保<strong>数据同步</strong>  在主节点出现故障<strong>切换到其它主节点</strong>/保持高可用性。</p><h5 id="4、缓存雪崩-缓存穿透-缓存击穿"><a href="#4、缓存雪崩-缓存穿透-缓存击穿" class="headerlink" title="4、缓存雪崩  缓存穿透   缓存击穿"></a>4、缓存雪崩  缓存穿透   缓存击穿</h5><p><strong>缓存雪崩（Cache Avalanche）：</strong> 缓存雪崩指的是在缓存中大量的缓存数据同时过期或失效，导致大量请求直接访问数据库或后端系统。这种情况通常发生在缓存中设置了相同的过期时间或缓存的数据都在同一时间失效，导致大量的请求落到数据库上，造成数据库压力剧增，甚至引发系统崩溃。</p><p><strong>解决方法：</strong></p><ul><li>设置缓存数据的过期时间时，可以引入随机值，避免数据同时过期。</li><li>使用分布式锁来保证只有一个线程或节点可以重新生成缓存数据，其他线程或节点等待或直接使用旧的缓存数据。</li></ul><p><strong>2. 缓存穿透（Cache Penetration）：</strong> 缓存穿透指的是在缓存中查找一个不存在的数据，导致该请求穿透缓存直接访问后端系统。这种情况通常发生在恶意攻击或大量请求查询不存在的数据时，造成后端系统负载增加。</p><p><strong>解决方法：</strong></p><ul><li>在缓存中设置一个空值（Null Object Pattern）或者使用布隆过滤器（Bloom Filter）等技术来过滤掉不存在的数据，避免查询数据库。</li><li>可以对一些可能存在的非法请求进行限制，例如使用请求频率限制或者IP白名单来过滤恶意请求。</li></ul><p><strong>3. 缓存击穿（Cache Breakdown）：</strong> 缓存击穿指的是一个非常热点的数据在缓存中过期后，恰好有大量的请求访问该数据，导致大量请求直接访问后端系统。这种情况通常发生在某个热点数据的缓存过期时间点，因为请求量过大，导致缓存刚刚失效就被重新生成。</p><p>缓存雪崩：大量数据同时实效</p><p>缓存穿透：大量访问一个不存在的键值</p><p>缓存击穿：某个热点数据消失  同时有大量访问请求访问该数据</p><h5 id="5、redis的持久化机制"><a href="#5、redis的持久化机制" class="headerlink" title="5、redis的持久化机制"></a>5、redis的持久化机制</h5><p><strong>RDB ： 快照持久化</strong></p><p><strong>AOF ： 日志持久化</strong></p><h5 id="6、Redis分布式锁底层是如何实现的"><a href="#6、Redis分布式锁底层是如何实现的" class="headerlink" title="6、Redis分布式锁底层是如何实现的"></a>6、Redis分布式锁底层是如何实现的</h5><p>Redis分布式锁是通过使用<strong>Redis的数据结构和命令</strong>来实现的，通常使用基于<strong>SETNX（SET if Not eXists）命令的方式来创建和释放锁</strong>。</p><h5 id="7、如何保证数据库和缓存的一致性"><a href="#7、如何保证数据库和缓存的一致性" class="headerlink" title="7、如何保证数据库和缓存的一致性"></a>7、如何保证数据库和缓存的一致性</h5><p><strong>1. 读写数据时维护一致性：</strong> 在应用程序中进行数据写入时，同时<strong>更新数据库和缓存</strong>。这确保了写入操作的原子性，从而避免了数据不一致的问题。然而，这种方法增加了应用程序的复杂性，并且可能导致性能损失，特别是在高并发情况下。</p><p><strong>2. 写穿透时处理缓存和数据库：</strong> 在缓存中查找数据时，如果缓存中不存在，就从数据库中读取，并将数据放入缓存。在这个过程中，如果其他并发请求也在同时尝试读取相同的数据，可以<strong>使用互斥锁来确保只有一个请求能够从数据库读取，而其他请求等待读取结果。这样可以防止写穿透，即在缓存失效的时间窗口内，大量并发请求直接访问数据库</strong>。</p><p><strong>3. 数据更新时同时更新数据库和缓存：</strong> 在数据更新的时候，应用程序同时更新数据库和缓存。这可以通过在更新数据库后，立即更新缓存来实现。这样做确保了数据的一致性，但也增加了复杂性和开销。</p><p><strong>4. 使用过期时间：</strong> 在设置缓存数据时，可以为缓存设置一个合理的过期时间，确保数据不会在缓存中过久，从而减少数据不一致的可能性。过期时间应根据业务需求来选择。</p><p><strong>5. 发布订阅机制：</strong> 使用发布订阅机制，当数据库的数据发生变化时，通知所有缓存节点进行更新。这样可以确保缓存中的数据与数据库中的数据保持同步。</p><p><strong>6. 双写策略：</strong> 双写策略指的是在进行数据更新时，首先更新缓存，然后再更新数据库。这样确保了数据在缓存和数据库中都是一致的。但也需要考虑写操作的原子性和失败处理，以防止数据不一致的情况。</p><p>①数据写入时  同时更新缓存和数据库</p><p>②缓存不存在就在数据库中读取  再把数据库中的数据写入缓存</p><p>③数据更新时 同时更新缓存和数据库</p><p>④ 给缓存设置合理过期时间  避免数据缓存失效后</p><p>⑤发布订阅机制  更新时通知所有节点</p><p>⑥双写策略  先更新缓存再更新数据库</p><h5 id="8、Redis有哪些数据结构-分别有哪些典型的应用场景"><a href="#8、Redis有哪些数据结构-分别有哪些典型的应用场景" class="headerlink" title="8、Redis有哪些数据结构  分别有哪些典型的应用场景"></a>8、Redis有哪些数据结构  分别有哪些典型的应用场景</h5><p>. 字符串（String）：**</p><ul><li>存储单个值或文本数据。</li><li>典型应用场景：缓存、计数器、计时器、分布式锁等。</li></ul><p><strong>2. 哈希表（Hash）：</strong></p><ul><li>存储字段和对应的值。</li><li>典型应用场景：存储对象、用户属性、缓存多个字段数据等。</li></ul><p><strong>3. 列表（List）：</strong></p><ul><li>存储有序的字符串列表。</li><li>典型应用场景：消息队列、任务队列、实时消息推送等。</li></ul><p><strong>4. 集合（Set）：</strong></p><ul><li>存储唯一的、无序的字符串元素。</li><li>典型应用场景：标签系统、好友关系、共同关注等。</li></ul><p><strong>5. 有序集合（Sorted Set）：</strong></p><ul><li>存储唯一的、有序的字符串元素，每个元素关联一个分数（score）用于排序。</li><li>典型应用场景：排行榜、热门数据统计、优先级队列等。</li></ul><p><strong>字符串 String/哈希表 Hash/列表 list/集合 set/有序集合 Sorted Set/</strong></p><h5 id="9、简述redis九大数据结构"><a href="#9、简述redis九大数据结构" class="headerlink" title="9、简述redis九大数据结构"></a>9、简述redis九大数据结构</h5><p><strong>1. 字符串（String）：</strong></p><ul><li>存储单个值或文本数据。</li><li>常用命令：SET、GET、INCR、DECR、APPEND等。</li></ul><p><strong>2. 哈希表（Hash）：</strong></p><ul><li>存储字段和对应的值。</li><li>常用命令：HSET、HGET、HDEL、HKEYS、HVALS等。</li></ul><p><strong>3. 列表（List）：</strong></p><ul><li>存储有序的字符串列表。</li><li>常用命令：LPUSH、RPUSH、LPOP、RPOP、LRANGE等。</li></ul><p><strong>4. 集合（Set）：</strong></p><ul><li>存储唯一的、无序的字符串元素。</li><li>常用命令：SADD、SREM、SMEMBERS、SINTER、SUNION等。</li></ul><p><strong>5. 有序集合（Sorted Set）：</strong></p><ul><li>存储唯一的、有序的字符串元素，每个元素关联一个分数（score）用于排序。</li><li>常用命令：ZADD、ZREM、ZRANGE、ZREVRANGE、ZINCRBY等。</li></ul><p><strong>6. 地理空间数据（Geo）：</strong></p><ul><li>存储地理位置信息。</li><li>常用命令：GEOADD、GEODIST、GEORADIUS、GEORADIUSBYMEMBER等。</li></ul><p><strong>7. 位图（Bitmap）：</strong></p><ul><li>存储位数据，支持对位的逻辑操作。</li><li>常用命令：SETBIT、GETBIT、BITOP、BITCOUNT等。</li></ul><p><strong>8. 超级日志（HyperLogLog）：</strong></p><ul><li>实现基数统计，用于快速估计大数据集合的基数（不重复元素的数量）。</li><li>常用命令：PFADD、PFCOUNT、PFMERGE等。</li></ul><p><strong>9. 带有阻塞特性的列表（Blocking List）：</strong></p><ul><li>类似于普通列表，但支持在列表为空时阻塞读取操作，直到有数据可读。</li><li>常用命令：BLPOP、BRPOP、BRPOPLPUSH等。</li></ul><h5 id="10、简述布隆过滤器的特点"><a href="#10、简述布隆过滤器的特点" class="headerlink" title="10、简述布隆过滤器的特点"></a>10、简述布隆过滤器的特点</h5><p>布隆过滤器（Bloom Filter）是一种用于快速判断一个元素是否属于一个集合的数据结构，它基于概率性的判断，具有高效的存储和查询特性。布隆过滤器主要用于解决大数据量下的查找问题，如判断一个URL是否已经被访问过，一个单词是否在词库中等。</p><p><strong>原理</strong>： 布隆过滤器基于一个位数组和一组哈希函数构建，其操作过程如下：</p><ol><li><strong>初始化</strong>：创建一个位数组，所有位都被初始化为0。</li><li><strong>插入元素</strong>：当一个元素需要插入时，使用多个哈希函数对元素进行计算，得到多个哈希值。将这些哈希值对应的位数组位置设置为1。</li><li><strong>查询元素</strong>：当查询一个元素是否存在时，同样使用多个哈希函数计算元素的哈希值，检查对应的位数组位置是否都为1。如果其中有任何一个位置为0，则可以确定元素不在集合中。如果所有位置都是1，说明元素可能存在于集合中，但实际上可能是误判。</li></ol><p><strong>优点</strong>：</p><ol><li><strong>空间效率高</strong>：布隆过滤器使用位数组存储信息，占用的内存较少，适用于大规模数据集。</li><li><strong>查询效率高</strong>：由于使用多个哈希函数，元素的查找速度很快。</li><li><strong>支持并行处理</strong>：布隆过滤器的查询和插入操作都不需要加锁，可以在并发环境下高效地使用。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>存在误判</strong>：由于布隆过滤器基于概率性的判断，可能会出现误判，即判断一个元素存在于集合中，但实际上并不存在。</li><li><strong>无法删除元素</strong>：一旦元素被插入到布隆过滤器中，无法删除。因为删除会影响到其他元素的判断结果。</li><li><strong>无法存储元素具体信息</strong>：布隆过滤器只能判断元素是否存在，但无法存储元素的具体信息。</li><li><strong>哈希函数的选择</strong>：选择适当的哈希函数对误判率和性能有一定的影响。</li></ol><p>总之，布隆过滤器适用于对内存要求较高、对查询速度要求较高，且可以容忍一定误判率的场景。在使用布隆过滤器时，需要根据实际情况权衡其优缺点，选择合适的参数和哈希函数。</p><p><strong>/创建数组  位数全部初始化为0/计算哈希值 设置位数为1(插入)/查询对应数组位置是否都为1 有任意一个为0则不存在（查询）/</strong></p><p><strong>缺点：容易误判</strong></p><h4 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h4><h5 id="1、常见的缓存淘汰算法"><a href="#1、常见的缓存淘汰算法" class="headerlink" title="1、常见的缓存淘汰算法"></a>1、常见的缓存淘汰算法</h5><p>①最近最久未使用</p><p>②先进先出</p><p>③最不经常使用</p><h5 id="2、分布式系统中常用的缓存方案"><a href="#2、分布式系统中常用的缓存方案" class="headerlink" title="2、分布式系统中常用的缓存方案"></a>2、分布式系统中常用的缓存方案</h5><p>①客户端缓存</p><p>②服务器端缓存</p><p>③数据库缓存</p><p>④nginx缓存</p><h5 id="3、缓存过期都有哪些策略"><a href="#3、缓存过期都有哪些策略" class="headerlink" title="3、缓存过期都有哪些策略"></a>3、缓存过期都有哪些策略</h5><p>①定期过期</p><p>②惰性过期</p><p>③定时过期</p><h5 id="4、Redis和Mysql如何保证数据一致"><a href="#4、Redis和Mysql如何保证数据一致" class="headerlink" title="4、Redis和Mysql如何保证数据一致"></a>4、Redis和Mysql如何保证数据一致</h5><p>1、先更新mysql  再更新redis</p><p>2、先删除redis  再更新mysql  再次查询时候将数据加入缓存</p><p>3、延时双删  先（延时）删除redis缓存数据  再更新mysql  延迟几百毫秒再删除redis缓存数据</p><h5 id="5、线程的生命周期和线程的状态"><a href="#5、线程的生命周期和线程的状态" class="headerlink" title="5、线程的生命周期和线程的状态"></a>5、线程的生命周期和线程的状态</h5><p>创建  new</p><p>就绪  start（）</p><p>运行 run</p><p>阻塞 block</p><p>死亡 dead</p><h5 id="6、说一下你知道的redis高可用方案"><a href="#6、说一下你知道的redis高可用方案" class="headerlink" title="6、说一下你知道的redis高可用方案"></a>6、说一下你知道的redis高可用方案</h5><p>1、集群模式</p><p>2、哨兵模式</p><h5 id="7、sleep（）-wait（）-join（）-yield（）的区别"><a href="#7、sleep（）-wait（）-join（）-yield（）的区别" class="headerlink" title="7、sleep（）  wait（）  join（） yield（）的区别"></a>7、sleep（）  wait（）  join（） yield（）的区别</h5><ul><li><code>sleep()</code> 用于暂停当前线程的执行，让出 CPU 时间，但不释放锁资源。</li><li><code>wait()</code> 用于线程间的同步和协调，使线程进入等待状态并释放锁资源，需要通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</li><li><code>join()</code> 用于等待其他线程执行完毕，常用于让线程按照一定顺序执行。</li><li><code>yield()</code> 用于提示调度器放弃当前线程的执行，让其他线程有更多的机会被调度执行，但调度器可以选择忽略它。</li></ul><h5 id="8、对线程安全的理解"><a href="#8、对线程安全的理解" class="headerlink" title="8、对线程安全的理解"></a>8、对线程安全的理解</h5><p>线程安全是指在多线程环境下，多个线程同时访问共享资源时，不会发生不正确的结果或导致数据异常的情况。确保线程安全是非常重要的，因为多线程并发访问共享资源可能导致数据不一致、竞态条件（Race Condition）、死锁等问题。</p><p>要实现线程安全，可以采取以下几种方法：</p><ol><li><strong>同步代码块/方法</strong>： 使用 <code>synchronized</code> 关键字对访问共享资源的代码块或方法进行同步，使得同一时间只有一个线程能够访问该代码块或方法。这样可以防止多个线程同时修改共享资源，确保数据的一致性。</li><li><strong>使用锁机制</strong>： Java 提供了 <code>Lock</code> 接口及其实现类 <code>ReentrantLock</code>，通过显式地加锁和解锁来保证多线程的同步访问。相比于 <code>synchronized</code> 关键字，锁提供了更灵活的控制和更多的功能。</li><li><strong>使用线程安全的数据结构</strong>： Java 提供了一些线程安全的数据结构，如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等，它们在多线程环境下能够保证数据的一致性和安全性。</li><li><strong>使用原子操作</strong>： Java 提供了一些原子操作类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，它们通过 CAS（Compare and Swap）操作来保证在多线程环境下对变量的原子性操作，从而避免竞态条件。</li><li><strong>避免共享资源</strong>： 尽量避免多个线程直接访问共享资源，通过将数据封装在对象内部，每个线程操作自己的对象实例，来避免竞争。</li><li><strong>线程本地变量</strong>： 使用 <code>ThreadLocal</code> 来为每个线程提供一个独立的变量副本，从而避免共享资源带来的竞争问题。</li></ol><p>*当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作  调用这个对象的行为都可以获得正确的结果  我们就说这个对象时线程安全的</p><h5 id="9、Thread和Runable的区别"><a href="#9、Thread和Runable的区别" class="headerlink" title="9、Thread和Runable的区别"></a>9、Thread和Runable的区别</h5><p>都继承于Thread类</p><p>Runable是接口</p><h5 id="10、说说你对守护线程的理解"><a href="#10、说说你对守护线程的理解" class="headerlink" title="10、说说你对守护线程的理解"></a>10、说说你对守护线程的理解</h5><p>守护线程为所有的费守护线程提供服务的线程  任何一个守护线程都是整个JVM中所有非守护线程的保姆</p><p>比如，在Java中，<strong>垃圾回收线程就是守护线程</strong>，它在后台自动回收不再被引用的对象。守护线程的存在可以保证这些辅助任务不会影响到程序的主要执行流程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视频项目开发</title>
      <link href="/2023/08/16/shi-pin-xiang-mu-kai-fa/"/>
      <url>/2023/08/16/shi-pin-xiang-mu-kai-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、定义切面日志类"><a href="#1、定义切面日志类" class="headerlink" title="1、定义切面日志类"></a>1、定义切面日志类</h4><pre class="line-numbers language-none"><code class="language-none">@Aspect@Componentpublic class LogAspect {    private final static Logger LOG = LoggerFactory.getLogger(LogAspect.class);    /** 定义一个切点 */    @Pointcut("execution(public * com.course.*.controller..*Controller.*(..))")    public void controllerPointcut() {}    @Before("controllerPointcut()")    public void doBefore(JoinPoint joinPoint) throws Throwable {        // 日志编号        MDC.put("UUID", UuidUtil.getShortUuid());        // 开始打印请求日志        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        Signature signature = joinPoint.getSignature();        String name = signature.getName();        // 打印业务操作        String nameCn = "";        if (name.contains("list") || name.contains("query")) {            nameCn = "查询";        } else if (name.contains("save")) {            nameCn = "保存";        } else if (name.contains("delete")) {            nameCn = "删除";        } else {            nameCn = "操作";        }        // 使用反射，获取业务名称        Class clazz = signature.getDeclaringType();        Field field;        String businessName = "";        try {            field = clazz.getField("BUSINESS_NAME");            if (!StringUtils.isEmpty(field)) {                businessName = (String) field.get(clazz);            }        } catch (NoSuchFieldException e) {            LOG.error("未获取到业务名称");        } catch (SecurityException e) {            LOG.error("获取业务名称失败", e);        }        // 打印请求信息        LOG.info("------------- 【{}】{}开始 -------------", businessName, nameCn);        LOG.info("请求地址: {} {}", request.getRequestURL().toString(), request.getMethod());        LOG.info("类名方法: {}.{}", signature.getDeclaringTypeName(), name);        LOG.info("远程地址: {}", request.getRemoteAddr());        // 打印请求参数        Object[] args = joinPoint.getArgs();        Object[] arguments  = new Object[args.length];        for (int i = 0; i &lt; args.length; i++) {            if (args[i] instanceof ServletRequest                    || args[i] instanceof ServletResponse                    || args[i] instanceof MultipartFile) {                continue;            }            arguments[i] = args[i];        }        // 排除字段，敏感字段或太长的字段不显示        String[] excludeProperties = {"shard"};        PropertyPreFilters filters = new PropertyPreFilters();        PropertyPreFilters.MySimplePropertyPreFilter excludefilter = filters.addFilter();        excludefilter.addExcludes(excludeProperties);        LOG.info("请求参数: {}", JSONObject.toJSONString(arguments, excludefilter)); // 为空的会不打印，但是像图片等长字段也会打印    }    @Around("controllerPointcut()")    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        long startTime = System.currentTimeMillis();        Object result = proceedingJoinPoint.proceed();        // 排除字段，敏感字段或太长的字段不显示        String[] excludeProperties = {"password", "shard"};        PropertyPreFilters filters = new PropertyPreFilters();        PropertyPreFilters.MySimplePropertyPreFilter excludefilter = filters.addFilter();        excludefilter.addExcludes(excludeProperties);        LOG.info("返回结果: {}", JSONObject.toJSONString(result, excludefilter));        LOG.info("------------- 结束 耗时：{} ms -------------", System.currentTimeMillis() - startTime);        return result;    }}这段代码是一个 Spring AOP 切面（Aspect），用于在 Controller 层的方法执行前后进行日志记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>@Aspect</code> 注解表示这是一个切面类，用于定义切面的横切关注点（cross-cutting concern）。</li><li><code>@Component</code> 注解将这个切面类注册为 Spring 的一个组件，以便 Spring 可以自动扫描和管理它。</li><li><code>@Pointcut</code> 注解定义了一个切点，表示在哪些方法上执行这个切面。在这里，切点定义为所有 <code>com.course.*.controller</code> 包下的 Controller 类的所有方法。</li><li><code>@Before</code> 注解表示在切点方法执行前执行 <code>doBefore</code> 方法。在这里，它用于记录请求的信息。</li><li><code>@Around</code> 注解表示在切点方法执行前后执行 <code>doAround</code> 方法。在这里，它用于记录方法执行前后的信息，以及方法的返回结果。</li></ol><p>在 <code>doBefore</code> 方法中，代码会记录请求的地址、方法名、远程地址、请求参数等信息。参数的敏感字段会被排除，不会被完全记录。</p><p>在 <code>doAround</code> 方法中，代码会记录方法的返回结果，同样会排除掉敏感字段。</p><p>这种 AOP 的方式可以帮助你在不修改具体方法代码的情况下，对请求的进出进行统一的日志记录。这样有助于了解方法的执行情况，进行问题排查等。</p><p>另外，代码中使用了 <code>PropertyPreFilters</code> 来过滤敏感字段，排除不需要在日志中记录的字段，从而保护敏感信息不被泄露。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序设计语言</title>
      <link href="/2023/04/13/cheng-xu-she-ji-yu-yan/"/>
      <url>/2023/04/13/cheng-xu-she-ji-yu-yan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="二、程序设计语言"><a href="#二、程序设计语言" class="headerlink" title="二、程序设计语言"></a>二、程序设计语言</h4><h5 id="1、低级语言和高级语言"><a href="#1、低级语言和高级语言" class="headerlink" title="1、低级语言和高级语言"></a>1、低级语言和高级语言</h5><p>​低级语言：机器语言、汇编语言</p><p>​高级语言：Java、C、C++等面向各类应用的程序设计语言</p><h5 id="2、编译程序和解释程序"><a href="#2、编译程序和解释程序" class="headerlink" title="2、编译程序和解释程序"></a>2、编译程序和解释程序</h5><p>​语言之间的翻译形式：汇编、解释和编译</p><p>​<strong>解释器</strong>：翻译源程序时不生成独立的目标程序</p><p>​解释程序和源程序要参与到程序的运行过程中</p><p>​<strong>编译器</strong>:翻译时将源程序翻译成独立保存的目标程序</p><p>​机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的运行过程</p><h5 id="3、程序设计语言基本成分"><a href="#3、程序设计语言基本成分" class="headerlink" title="3、程序设计语言基本成分"></a>3、程序设计语言基本成分</h5><p>​程序设计语言的基本成分：数据、运算、控制和传输等</p><p>​程序的三种基本结构：顺序、选择、循环（重复）</p><p>​程序设计语言中规定数据必须有类型，有以下三个优点</p><ol><li>便于为数据合理分配存储单元</li><li>便于对参与表达式计算的数据对象进行检查</li><li>便于规定数据对象的取值范围及能够进行的运算</li></ol><h5 id="4、传值调用与地址调用"><a href="#4、传值调用与地址调用" class="headerlink" title="4、传值调用与地址调用"></a>4、传值调用与地址调用</h5><p>传值调用:将<strong>实参</strong>的值传递给<strong>形参</strong>，<strong>实参</strong>可以是变量、常量和表达式。不可以实现形参和实参间双向传递数据的效果</p><p>传引用 (地址) 调用:将<strong>实参</strong>的地址传递给<strong>形参</strong>，<strong>实参</strong>必须有地址，实参不能是常量 (值)，表达式。可以实现形参和实参间双向传递数据的效果，即改变形参的值同时也改变了实参的值。</p><h5 id="5、解释程序翻译阶段"><a href="#5、解释程序翻译阶段" class="headerlink" title="5、解释程序翻译阶段"></a>5、解释程序翻译阶段</h5><p><strong>编译方式</strong>:   词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成</p><p><strong>解释方式</strong>：词法分析、语法分析、语义分析</p><p>编译器和解释器都不可省略词法分析、语法分析、语义分析且顺序不可交换即词法分析、语法分析、语义分析是必须的。</p><p>编译器方式中中间代码生成和代码优化不是必要，可省略。即编译器方式可以在词法分析、语法分析、语义分析阶段后直接生成目标代码</p><p><a href="https://imgse.com/i/p9ShxqP"><img src="https://s1.ax1x.com/2023/04/15/p9ShxqP.png" alt="p9ShxqP.png"></a></p><h5 id="6、符号表"><a href="#6、符号表" class="headerlink" title="6、符号表"></a>6、符号表</h5><p><strong>符号表</strong>:不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入符号表中记录源程序中各个字符的必要信息，以辅助语义的正确性检查和代码生成。</p><h5 id="7、词法分析、语法分析、语义分析"><a href="#7、词法分析、语法分析、语义分析" class="headerlink" title="7、词法分析、语法分析、语义分析"></a>7、词法分析、语法分析、语义分析</h5><p><strong>词法分析</strong>输入:源程序; 输出: 记号流</p><p>词法分析阶段的主要作用是:分析构成程序的字符及由字符按照构造规则构成的符号是否符合程序语言的规定</p><p><strong>语法分析</strong>输入:记号流;输出: 语法树 (分析树)</p><p>语法分析阶段可以发现程序中所有的语法错误语法分析阶段的主要作用是:对各条语句的结构进行合法性分析分析程序中的句子结构是否正确</p><p><strong>语义分析</strong>输入: 语法树 (分析树)</p><p>语义分析阶段的主要作用是进行类型分析和检查</p><p>语义分析阶段<strong>不能</strong>发现程序中所有的语义错误</p><p>语义分析阶段<strong>可以</strong>发现静态语义错误</p><p><strong>不能</strong>发现动态语义错误，动态语义错误运行时才能发现</p><h5 id="8、目标代码生成"><a href="#8、目标代码生成" class="headerlink" title="8、目标代码生成"></a>8、目标代码生成</h5><p><strong>目标代码</strong>生成目标代码生成阶段的工作与具体的机器密切相关寄存器的分配工作处于目标代码生成阶段</p><h5 id="9、中间代码生成"><a href="#9、中间代码生成" class="headerlink" title="9、中间代码生成"></a>9、中间代码生成</h5><p>常见的中间代码有: 后缀式、三地址码、三元式、四元式和树(图) 等形式</p><p>中间代码与具体的机器无关 (不依赖具体的机器)可以将不同的高级程序语言翻译成同一种中间代码中间代码可以跨平台。</p><p>因为与具体的机器无关，使用中间代码有利于进行与机器无关的优化处理和提高编译程序的可移植性</p><h5 id="10、正规式"><a href="#10、正规式" class="headerlink" title="10、正规式"></a>10、正规式</h5><p><a href="https://imgse.com/i/p9FuyXq"><img src="https://s1.ax1x.com/2023/04/19/p9FuyXq.png" alt="p9FuyXq.png"></a></p><h5 id="11、有限自动机"><a href="#11、有限自动机" class="headerlink" title="11、有限自动机"></a>11、有限自动机</h5><p><strong>有限自动机</strong>是<strong>词法分析</strong>的一个工具，它能正确地识别正规集<br><strong>确定的有限自动机</strong> (DFA) : 对每一个状态来说识别字符后转移的状态是唯一的</p><p><strong>不确定的有限自动机</strong> (NFA) : 对每一个状态来说识别字符后转移的状态是不唯一的</p><h5 id="12、上下文无关文法"><a href="#12、上下文无关文法" class="headerlink" title="12、上下文无关文法"></a>12、上下文无关文法</h5><p><a href="https://imgse.com/i/p9Fur1s"><img src="https://s1.ax1x.com/2023/04/19/p9Fur1s.png" alt="p9Fur1s.png"></a></p><p><a href="https://imgse.com/i/p9Fuscn"><img src="https://s1.ax1x.com/2023/04/19/p9Fuscn.png" alt="p9Fuscn.png"></a></p><p><strong>推出来的句子最后必须全部是终结符号</strong></p><p><strong>终结符号：无法再往下继续推导的符号</strong></p><h5 id="13、中缀、后缀表达式的转换"><a href="#13、中缀、后缀表达式的转换" class="headerlink" title="13、中缀、后缀表达式的转换"></a>13、中缀、后缀表达式的转换</h5><p>中缀式：a ? b</p><p>后缀式（逆波兰式）：ab?</p><p>优先级：①（）②  x ,/  ③ +,-</p><p>中缀变后缀：优先级相同，从右向左算</p><p>后缀变中缀：采用栈的概念  ，从左到右依次入栈，遇到运算符计算后再入栈。</p><p>中缀二叉树：左根右</p><p>后缀二叉树：左右根</p><h5 id="14、杂题精选"><a href="#14、杂题精选" class="headerlink" title="14、杂题精选"></a>14、杂题精选</h5><ul><li><p>LISP是一种函数式编程语言</p></li><li><p>Prolog是一种逻辑式编程语言</p></li><li><p>语法指导翻译是一种静态语义分析</p></li><li><p>计算机执行程序时，内存分为静态数据区、代码区、栈区和堆区。</p><p>栈区一般再进行函数调用和返回时由系统进行控制和管理</p><p>堆区由用户在程序中根据需要申请和释放</p></li><li><p>C/C++语言为某个应用编写的程序，经过<strong>预处理、编译、汇编、链接</strong>后形成执行程序。</p></li><li><p>python是脚本语言  是一个解释型语言，不是编译型语言</p></li><li><p><a href="https://imgse.com/i/p9FuDpj"><img src="https://s1.ax1x.com/2023/04/19/p9FuDpj.png" alt="p9FuDpj.png"></a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
